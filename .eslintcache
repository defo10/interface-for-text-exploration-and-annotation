[{"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/index.js":"1","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Data.tsx":"2","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Layout.tsx":"3","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/ProjectionElements/Projection.tsx":"4","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/ProjectionElements/ProjectionParameters.tsx":"5","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/ProjectionElements/Sliders.tsx":"6","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/index.js":"7","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/ClusterDetailsLayout.tsx":"8","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterOverview/ClusterTable.tsx":"9","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/ListItemComment.tsx":"10","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/Comment.tsx":"11","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/ClusterMenu.tsx":"12","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/ClusterChangeCommentDialog.tsx":"13","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/App.tsx":"14","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarOverview.tsx":"15","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarDetails.tsx":"16","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterOverview/ClusterMerger.tsx":"17","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterOverview/ClustersOverview.tsx":"18"},{"size":163,"mtime":1631709986577,"results":"19","hashOfConfig":"20"},{"size":19588,"mtime":1631707681794,"results":"21","hashOfConfig":"20"},{"size":7191,"mtime":1631708186684,"results":"22","hashOfConfig":"20"},{"size":10556,"mtime":1631708497876,"results":"23","hashOfConfig":"20"},{"size":2081,"mtime":1631712491306,"results":"24","hashOfConfig":"20"},{"size":4557,"mtime":1631712491316,"results":"25","hashOfConfig":"20"},{"size":185,"mtime":1620315276875,"results":"26","hashOfConfig":"20"},{"size":6676,"mtime":1631709795662,"results":"27","hashOfConfig":"20"},{"size":11309,"mtime":1631709593377,"results":"28","hashOfConfig":"20"},{"size":3260,"mtime":1631709928331,"results":"29","hashOfConfig":"20"},{"size":4433,"mtime":1631709795662,"results":"30","hashOfConfig":"20"},{"size":1363,"mtime":1631709795658,"results":"31","hashOfConfig":"20"},{"size":3390,"mtime":1631709699503,"results":"32","hashOfConfig":"20"},{"size":1049,"mtime":1631708325122,"results":"33","hashOfConfig":"20"},{"size":988,"mtime":1631712851815,"results":"34","hashOfConfig":"20"},{"size":1221,"mtime":1631708186684,"results":"35","hashOfConfig":"20"},{"size":3565,"mtime":1631709059851,"results":"36","hashOfConfig":"20"},{"size":3639,"mtime":1631712851815,"results":"37","hashOfConfig":"20"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},"1awlnhx",{"filePath":"41","messages":"42","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"40"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"48","usedDeprecatedRules":"40"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"55","messages":"56","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"57","usedDeprecatedRules":"40"},{"filePath":"58","messages":"59","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"66"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"77","usedDeprecatedRules":"40"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"40"},"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/index.js",[],[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Data.tsx",["80","81","82","83"],"// this class is responsible for loading all data\n// and parsing it into the right format\nimport * as d3 from 'd3'\nimport * as _ from 'lodash'\nimport lunr from 'lunr'\nimport React, { Component } from 'react'\nimport Layout from './Layout'\n\nexport type Coordinate = {\n  x: number,\n  y: number,\n  index: number\n}\n\nexport const min_dists_arr: string[] = ['0.1', '0.2', '0.5', '0.9']\nexport type ParameterMinDist = '0.1' | '0.2' | '0.5' | '0.9'\nexport type MinDist = {\n  '0.1': Coordinate[] | null,\n  '0.2': Coordinate[] | null,\n  '0.5': Coordinate[] | null,\n  '0.9': Coordinate[] | null,\n  [i: string]: Coordinate[] | null\n}\n\nexport const num_neighbors_arr: string[] = ['2', '5', '10', '50']\nexport type ParameterNumNeighbors = '2' | '5' | '10' | '50'\nexport type NumNeighbors = {\n  '2': MinDist,\n  '5': MinDist,\n  '10': MinDist,\n  '50': MinDist,\n  [i: string]: MinDist\n}\n\n/** used to keep track of changed label */\nexport type DataChanged = {\n  oldLabel: Label\n  newLabel: Label\n} & DataPoint\n\nexport type DataPoint = {\n  publishedAt: string,\n  authorName: string,\n  isReply: number,\n  text: string | null,\n  cleaned: string,\n  i: number\n}\n\nexport type Label = {\n  label_kmedoids: string\n}\n\nexport type ClusterInfo = {\n  /** is the index of the medoid of that data point.\n   * medoid might be null for newly created clusters.\n  */\n  medoid: number | null,\n  /** are the indices of representatives of this cluster */\n  representatives: number[],\n  size: number,\n  quality: number\n}\n\nexport type Cluster = {\n  [cluster: string]: ClusterInfo\n}\n\nexport type ChangedClusterName = {\n  original: String,\n  changed: String\n}\n\ntype State = {\n  /** this has actually all coordinates, unlike allCoordinates,\n   * which has a sample for all parameters */\n  allCoordinatesFull: NumNeighbors | null,\n  /** samples to show of selected coordinate parameters */\n  allCoordinates: Coordinate[] | null,\n  /** true iff coordinates are reloading */\n  coordsAreReloading: boolean,\n  coordinatesParameters: {\n    numNeighborsParameter: ParameterNumNeighbors,\n    minDistParameter: ParameterMinDist,\n  }\n  coordinates_to_show: number, // i.e. all svg circles to show\n  data: DataPoint[] | null,\n  /** data that was moved between clusters */\n  dataChanged: DataChanged[]\n  labels: Label[] | null,\n  searchIndex: lunr.Index | null,\n  /** is an array of cluster names to show on the projection */\n  clustersToShow: string[],\n  /** meta info about each cluster in a dictionary */\n  clusters: Cluster,\n  /** the coordinate of the comment the user hovers over, or null if not hovering */\n  hoveredCommentCoordinate: Coordinate | null,\n  /** the copy of the original cluster name and the current local change */\n  changedClusterName: ChangedClusterName | null\n}\n\nexport type PropsFromData = {\n  /** reloads newSize many coordinates that will be shown in Projection  */\n  reloadCoordinatesWithSize: (newSize: number, callback?: () => void) => void,\n  setSelectedCoordinates: (numNeighbors: ParameterNumNeighbors, minDist: ParameterMinDist) => void,\n  /**\n   *\n   * @param clusters is an array of labels of the clusters to show\n   */\n  setClustersToShow: (clusters: string[], callback?: () => void) => void,\n  /**\n   * changes all occurences of oldLabel to newLabel inside labels and\n   * clustersToShow.\n   * Make sure to handle all lower lying variables, e.g. selectedCluster,\n   * yourself.\n   * @param oldLabels\n   * @param newLabel\n   */\n  renameLabels: (oldLabels: string[], newLabel: string) => void,\n  /**\n   * adds new entry to dataChanged\n   * if entry with same i property already exists, then first remove that.\n   * if oldlabel is the same as newlabel, then remove and don't add\n   * updates clusters state too\n   */\n  pushToDataChanged: (newDataChange: DataChanged) => void,\n  /**\n   * sets hoveredCommentCoordinate to the coordinate associated with\n   * comment_index, or null of comment_index is null\n   */\n  setHoveredCommentCoordinate: (comment_index: number | null) => void,\n  /** set changedClusterName, i.e. object which keeps track of the local\n   * changes of a cluster name.\n   *\n   * Reset whenever a different cluster is selected.\n   */\n  setChangedClusterName: (changedClusterName: ChangedClusterName) => void,\n  [key: string]: any,\n} & State\n\nexport default class Data extends Component<any, State> {\n  random_indices: number[] | null = null\n\n  constructor (props: any) {\n    super(props)\n    this.state = {\n      allCoordinatesFull: null,\n      allCoordinates: null,\n      coordsAreReloading: false,\n      coordinatesParameters: {\n        numNeighborsParameter: '10',\n        minDistParameter: '0.1'\n      },\n      coordinates_to_show: 500,\n      data: null,\n      labels: null,\n      searchIndex: null,\n      clustersToShow: Array.from(Array(40).keys()).map(n => `cluster ${n}`),\n      clusters: {},\n      dataChanged: [],\n      hoveredCommentCoordinate: null,\n      changedClusterName: null\n    }\n    this.reloadCoordinatesWithSize = this.reloadCoordinatesWithSize.bind(this)\n    this.setSelectedCoordinates = this.setSelectedCoordinates.bind(this)\n    this.setClustersToShow = this.setClustersToShow.bind(this)\n    this.renameLabels = this.renameLabels.bind(this)\n    this.pushToDataChanged = this.pushToDataChanged.bind(this)\n    this.setHoveredCommentCoordinate = this.setHoveredCommentCoordinate.bind(this)\n    this.setChangedClusterName = this.setChangedClusterName.bind(this)\n  }\n\n  setChangedClusterName (changedClusterName: ChangedClusterName) {\n    this.setState({\n      changedClusterName: changedClusterName\n    })\n  }\n\n  setHoveredCommentCoordinate (comment_index: number | null) {\n    if (!comment_index) {\n      this.setState({\n        hoveredCommentCoordinate: null\n      })\n      return\n    }\n    if (!this.state.allCoordinatesFull) return\n    const allComments = this.state.allCoordinatesFull[this.state.coordinatesParameters.numNeighborsParameter][this.state.coordinatesParameters.minDistParameter]\n    this.setState({\n      hoveredCommentCoordinate: allComments![comment_index]\n    })\n  }\n\n  pushToDataChanged (newData: DataChanged) {\n    const alreadyExisting = _.find(this.state.dataChanged, ['i', newData.i])\n    const newDataChanged = _.without(this.state.dataChanged, alreadyExisting)\n\n    const userRevertedChange = alreadyExisting && alreadyExisting.oldLabel.label_kmedoids == newData.newLabel.label_kmedoids\n    const noChange = !alreadyExisting && newData.oldLabel.label_kmedoids == newData.newLabel.label_kmedoids\n    if (!userRevertedChange || noChange) newDataChanged.push(newData)\n\n    // if new cluster, set clusters\n    if (!this.state.clusters[newData.newLabel.label_kmedoids]) {\n      const copy = { ...this.state.clusters }\n      copy[newData.newLabel.label_kmedoids] = {\n        medoid: null,\n        representatives: [],\n        size: 1,\n        quality: -1\n      }\n      this.setState({\n        clusters: copy\n      })\n    }\n\n    this.setState({\n      dataChanged: newDataChanged as DataChanged[]\n    })\n  }\n\n  renameLabels (oldLabels: string[], newLabel: string) {\n    // rename in clusterToShow\n    const newClustersToShow = this.state.clustersToShow.map(\n      (el, i) => oldLabels.includes(el) ? newLabel : el\n    )\n\n    // rename in labels\n    const labels_new = this.state.labels!.map(\n      (label) => {\n        if (oldLabels.includes(label.label_kmedoids)) {\n          return { label_kmedoids: newLabel } as Label\n        }\n        return label\n      }\n    )\n\n    // rename in clusters\n    const clusters_new: Cluster = _.cloneDeep(this.state.clusters)\n    let didMerge = false\n    for (const oldLabel of oldLabels) {\n      if (oldLabel == newLabel) continue // skip merging if both already have same label\n\n      const isMerging = clusters_new[newLabel]\n      if (isMerging) { // merge if new already exists\n        didMerge = true\n        clusters_new[newLabel] = {\n          medoid: clusters_new[newLabel].medoid,\n          representatives: [...clusters_new[oldLabel].representatives, ...clusters_new[newLabel].representatives],\n          size: clusters_new[oldLabel].size + clusters_new[newLabel].size,\n          quality: -1\n        }\n      } else { // rename else\n        clusters_new[newLabel] = { ...this.state.clusters[oldLabel] }\n      }\n      delete clusters_new[oldLabel]\n    }\n\n    // rename in dataChanged\n    const dataChanged_new = this.state.dataChanged.map(el => // change 'from' field\n      (oldLabels.includes(el.oldLabel.label_kmedoids))\n        ? { ...el, oldLabel: { label_kmedoids: newLabel } }\n        : el\n    ).map(el => // change 'to' field\n      (oldLabels.includes(el.newLabel.label_kmedoids))\n        ? { ...el, newLabel: { label_kmedoids: newLabel } }\n        : el\n    )\n\n    this.setState({\n      clustersToShow: newClustersToShow,\n      labels: labels_new,\n      clusters: clusters_new,\n      dataChanged: dataChanged_new\n    }, () => {\n      if (didMerge) this.calc_quality()\n    })\n  }\n\n  /** updates coordinates of current points to updated coordinate parameters.\n   * Call this function after changing the coordinate parameters\n   *\n   * @param callback is called after allCoordinates is set\n   *\n   * @pre this.state.allCoordinates !== null\n   */\n  updateSelectedCoordinates (callback?: () => void) {\n    if (!this.state.allCoordinatesFull) throw Error('allCoordinates is null')\n\n    const numNeighbors = this.state.coordinatesParameters.numNeighborsParameter\n    const minDist = this.state.coordinatesParameters.minDistParameter\n\n    let coordinates\n    if (!this.state.allCoordinates) {\n      const randIndices = this.getRandomIndices(this.state.labels || [], this.state.coordinates_to_show)\n      coordinates = randIndices.map(i => this.state.allCoordinatesFull![numNeighbors][minDist]![i])\n    } else {\n      // take same points and update coordinates\n      // this allows for nice transitions as the points remain the same\n      coordinates = this.state.allCoordinates!.map(i => this.state.allCoordinatesFull![numNeighbors][minDist]![i.index])\n    }\n\n    this.setState({\n      allCoordinates: coordinates\n    }, callback)\n  }\n\n  setClustersToShow (clusters: string[], callback?: () => void) {\n    this.setState({\n      clustersToShow: clusters\n    })\n  }\n\n  /** unlike getSelectedCoordinates, this returns all coordinates,\n   * not only a sample\n   */\n  _getAllSelectedCoordinates () {\n    if (!this.state.allCoordinatesFull) {\n      console.log('allCoordinatesFull is null')\n      return []\n    }\n    const numNeighbors = this.state.coordinatesParameters.numNeighborsParameter\n    const minDist = this.state.coordinatesParameters.minDistParameter\n    return this.state.allCoordinatesFull[numNeighbors][minDist] || []\n  }\n\n  setSelectedCoordinates (numNeighbors: ParameterNumNeighbors, minDist: ParameterMinDist) {\n    this.setState({\n      coordinatesParameters: {\n        numNeighborsParameter: numNeighbors,\n        minDistParameter: minDist\n      }\n    }, this.updateSelectedCoordinates) // then update svg points\n  }\n\n  /**\n   * scales embeddings to values between [0, 10]\n   * the index key stays untouched.\n   * @param embeddings are the coordinates, has form [{x->val,y->val, index->val},...]\n   * @returns an array of the coordinates of the form [[x, y, index], ...]\n   */\n  scaleEmbeddings (embeddings: Coordinate[]) {\n    const xs = embeddings.map(e => Math.abs(e.x))\n    const ys = embeddings.map(e => Math.abs(e.y))\n    const max_x = _.max(xs) || 0\n    const max_y = _.max(ys) || 0\n    const max = Math.max(max_x, max_y)\n    const scale = d3\n      .scaleLinear()\n      .domain([-max, max])\n      .range([0, 100])\n    const scaled_embeddings = embeddings.map(e => {\n      const coordinate_scaled: Coordinate = {\n        x: scale(e.x), y: scale(e.y), index: e.index\n      }\n      return coordinate_scaled\n    }\n    )\n    return scaled_embeddings\n  }\n\n  /**\n   * picks n random elements from arr without duplicates.\n   *\n   * if n is longer than 4/5th of arr's length, random indices of the lenght of the whole\n   * list @param arr is  returned as a random picks would take too many tries to find new indices.\n   *\n   * modified from\n   * https://stackoverflow.com/questions/19269545/how-to-get-a-number-of-random-elements-from-an-array\n   *\n   * @param {*} arr the original giving the shape\n   * @param {*} n how many to pick from\n   */\n  getRandomIndices (arr: any[], n: number) {\n    const indices_arr = Array.from(Array(arr.length).keys()) // why so difficult, js?\n\n    if (n > indices_arr.length * 3 / 5) {\n      return indices_arr\n    }\n\n    const result = new Array(n)\n    let len = indices_arr.length\n    const taken = new Array(len)\n    if (n > len) { throw new RangeError('getRandom: more elements taken than available') }\n    while (n--) {\n      const x = Math.floor(Math.random() * len)\n      result[n] = indices_arr[x in taken ? taken[x] : x]\n      taken[x] = --len in taken ? taken[len] : len\n    }\n    return result\n  }\n\n  /**\n   * how many coordinates to pcik form all clusters to show coordinates\n   * @param howMany how many to numbers to pick from all clusters to show\n   */\n  async loadCoordinates (howMany: number) {\n    const all_coordinates_full: NumNeighbors = {\n      2: { 0.1: null, 0.2: null, 0.5: null, 0.9: null } as MinDist,\n      5: { 0.1: null, 0.2: null, 0.5: null, 0.9: null } as MinDist,\n      10: { 0.1: null, 0.2: null, 0.5: null, 0.9: null } as MinDist,\n      50: { 0.1: null, 0.2: null, 0.5: null, 0.9: null } as MinDist\n    }\n\n    // creates a combination of all above, i.e. [['2', '0.1'], ['2', '0.2'], ...]\n    const allParamsPairs = Object.keys(all_coordinates_full).flatMap(\n      numNeigbor => Object.keys(all_coordinates_full['2'])\n        .map(mindistEl => [numNeigbor, mindistEl])\n    )\n\n    const allPromisesParamPairs: Promise<boolean>[] = allParamsPairs.map(paramaterPair => {\n      const num_neighbors = paramaterPair[0]\n      const min_dist = paramaterPair[1]\n      return fetch(`${process.env.PUBLIC_URL}/coordinates/coordinates_supervised.${num_neighbors}.${min_dist}.json`)\n        .then((fetched: Response) => fetched.json())\n        .then((coordinates: Coordinate[]) => {\n          const scaled_coordinates: Coordinate[] = this.scaleEmbeddings(coordinates)\n          all_coordinates_full[num_neighbors][min_dist] = scaled_coordinates\n          return true\n        })\n    })\n\n    await Promise.all(allPromisesParamPairs)\n\n    return this.setState({\n      allCoordinatesFull: all_coordinates_full\n    }, this.calc_quality) // calc_quality doesnt do anything on first run\n  }\n\n  async reloadCoordinatesWithSize (newSize: number, callback?: () => void) {\n    // if above 80 %, just take all points\n    const size = newSize > 4 / 5 * (this.state.data?.length || 0) ? (this.state.data?.length || 0) : newSize\n\n    const numNeighbors = this.state.coordinatesParameters.numNeighborsParameter\n    const minDist = this.state.coordinatesParameters.minDistParameter\n\n    const randIndices = this.getRandomIndices(this.state.labels || [], size)\n    const coordinates = randIndices.map(i => this.state.allCoordinatesFull![numNeighbors][minDist]![i])\n\n    this.setState({\n      coordinates_to_show: size,\n      allCoordinates: coordinates\n    })\n  }\n\n  async loadDataAndSearchIndex () {\n    const fetched = await fetch(`${process.env.PUBLIC_URL}/data.json`)\n    const data: DataPoint[] = JSON.parse(await fetched.text())\n    data.forEach((el, i) => {\n      el.i = i\n    })\n    const search_index = lunr(function () {\n      this.field('comment')\n      this.field('author')\n      this.field('published')\n\n      for (let i = 0; i < data.length; i++) {\n        this.add({\n          comment: data[i].cleaned,\n          author: data[i].authorName,\n          published: data[i].publishedAt,\n          id: `${i}`\n        })\n      }\n    })\n    this.setState({\n      data: data,\n      searchIndex: search_index\n    })\n  }\n\n  async loadLabels () {\n    const fetched = await fetch(`${process.env.PUBLIC_URL}/labels.json`)\n    let labels: Label[] = JSON.parse(await fetched.text())\n    labels = labels.map(el => {\n      return {\n        label_kmedoids: `cluster ${el.label_kmedoids}`\n      }\n    })\n\n    this.setState({\n      labels: labels\n    })\n  }\n\n  /** normalizes cluster quality so that values are in the range [0,1] */\n  _normalize_clusters (clusters: Cluster) {\n    let maxQuality = 0\n    for (const label in clusters) {\n      maxQuality = clusters[label].quality > maxQuality ? clusters[label].quality : maxQuality\n    }\n    const scale = d3.scaleLinear().domain([0, maxQuality]).range([0, 1])\n    for (const label in clusters) {\n      clusters[label].quality = scale(clusters[label].quality)\n    }\n  }\n\n  /** sets the quality for each cluster.\n   * currently named as density\n   */\n  calc_quality () {\n    // using average of squared euclidean distances\n    const clusters = { ...this.state.clusters }\n    for (const label in clusters) {\n      if (!clusters[label].medoid) return // doesnt happen\n      const coordinates = this._getAllSelectedCoordinates()\n      const medoid_pos = coordinates[clusters[label].medoid!]\n\n      const distances = coordinates.map(\n        (coord) => {\n          // eslint-disable-next-line array-callback-return\n          if (this.state.labels?.[coord.index].label_kmedoids != label) return\n          // is of same cluster:\n          const sqrd_eucl_dist = Math.sqrt(Math.pow(coord.x - medoid_pos.x, 2) + Math.pow(coord.y - medoid_pos.y, 2))\n          return sqrd_eucl_dist\n        }\n      )\n\n      clusters[label].quality = _.mean(distances)\n    }\n\n    this._normalize_clusters(clusters)\n\n    this.setState({\n      clusters: clusters\n    })\n  }\n\n  /** loads cluster representatives from disk and creates clusters state */\n  async loadClusters () {\n    const fetchedReprs = await fetch(`${process.env.PUBLIC_URL}/cluster-representatives.json`)\n    const representatives: { [label: string]: number[] } = JSON.parse(await fetchedReprs.text())\n\n    const fetchedMedoids = await fetch(`${process.env.PUBLIC_URL}/medoids.json`)\n    const medoids: { medoids_indices: number }[] = JSON.parse(await fetchedMedoids.text())\n\n    const clusters: Cluster = {}\n\n    for (const orig_label in representatives) {\n      const changed_label = `cluster ${orig_label}`\n      clusters[changed_label] = {\n        medoid: medoids[parseInt(orig_label)].medoids_indices,\n        representatives: representatives[parseInt(orig_label)],\n        size: 0,\n        quality: 0\n      }\n    }\n\n    for (const label of this.state.labels!) {\n      clusters[label.label_kmedoids].size += 1\n    }\n\n    this.setState({\n      clusters: clusters\n    }, () => this.calc_quality())\n  }\n\n  async componentDidMount () {\n    await Promise.all([\n      this.loadCoordinates(this.state.coordinates_to_show), // embeddings\n      this.loadDataAndSearchIndex(),\n      this.loadLabels()\n    ])\n    await this.setSelectedCoordinates(this.state.coordinatesParameters.numNeighborsParameter, this.state.coordinatesParameters.minDistParameter)\n    await this.loadClusters()\n  }\n\n  render () {\n    const props: PropsFromData = {\n      ...this.state,\n      reloadCoordinatesWithSize: this.reloadCoordinatesWithSize,\n      setSelectedCoordinates: this.setSelectedCoordinates,\n      setClustersToShow: this.setClustersToShow,\n      renameLabels: this.renameLabels,\n      pushToDataChanged: this.pushToDataChanged,\n      setHoveredCommentCoordinate: this.setHoveredCommentCoordinate,\n      setChangedClusterName: this.setChangedClusterName\n    }\n    return this.state.allCoordinates && this.state.data && this.state.labels && this.state.clusters\n      ? (\n      <Layout {...props} />\n        )\n      : (\n        <div style={{ padding: '1rem' }}>Loading data...</div>\n        )\n  }\n}\n","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Layout.tsx",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/ProjectionElements/Projection.tsx",["84","85"],"// this is a component doing all the d3 stuff\n// of the visualization\nimport React, { Component } from 'react'\nimport * as d3 from 'd3'\nimport { Coordinate, PropsFromData } from '../Data'\nimport { ZoomBehavior } from 'd3-zoom'\nimport _ from 'lodash'\n\nexport type PropsForProjection = {\n  width: number,\n  height: number,\n  sidebar_ctx: number,\n  selectedCluster: string | null,\n  selectCluster: (newLabel: string) => void,\n  setSelectedDatum: (newDatumIndex: number) => void,\n  selected_datum: number | null,\n  searchResultIndices: object & {\n    [key: string]: any | null\n  },\n  /** this is the same as allCoordinates with only clusters selected to show, but\n   * arranged as array of arrays of form [x, y, index].\n   * This increases the performance substantially\n   *\n   * its actually a number[] but ts was giving errors when unpacking those\n  */\n  allCoordinatesAsArray: any[]\n} & PropsFromData\n\nclass Projection extends Component<PropsForProjection, {}> {\n  ref: SVGSVGElement | null = null\n  svg: d3.Selection<SVGSVGElement, any, null, undefined> | null = null\n  group: d3.Selection<SVGGElement, any, null, undefined> | null = null\n  scaleTransform: any = null\n  zoomBehavior: ZoomBehavior<SVGSVGElement, Coordinate> | null = null\n  fillOpacity = 0.8\n  hoverColor = 'rgba(245, 124, 0, 1)' // orange\n\n  constructor (props: PropsForProjection) {\n    super(props)\n    this.state = {}\n  }\n\n  async drawScatterPlot () {\n    if (!this.ref) return\n\n    const {\n      width, height, setSelectedDatum, allCoordinatesAsArray,\n      selectCluster, labels\n    } = this.props\n    this.svg = !this.svg ? d3.select(this.ref) : this.svg\n    this.group = !this.group\n      ? this.svg.append('g')\n      : this.group\n\n    const coordsToShow = allCoordinatesAsArray\n\n    const circles = await this.group.selectAll('circle')\n      .data(coordsToShow, ([,, index]) => index)\n      .join(\n        enter => enter.append('circle')\n          .attr('id', ([,, index]) => index)\n          .attr('cx', ([x]) => x)\n          .attr('cy', ([, y]) => y)\n          .attr('fill-opacity', 0.0)\n          .call(enter => enter\n            .transition()\n            .duration(500)\n            .delay((d, i) => i / this.props.coordinates_to_show * 200) // Dynamic delay (i.e. each item delays a little longer)\n            .attr('fill-opacity', this.fillOpacity)\n          )\n        ,\n        update => update\n          .call(update => update\n            .transition()\n            .duration(2000)\n            .attr('cx', ([x]) => x)\n            .attr('cy', ([, y]) => y)\n          ),\n        exit => exit\n          .call(text => text.transition()\n            .duration(500)\n            .delay((d, i) => i / this.props.coordinates_to_show * 200) // Dynamic delay (i.e. each item delays a little longer)\n            .remove()\n            .attr('fill-opacity', 0)\n          )\n      )\n      .attr('r', 0.5)\n      .attr('fill', 'white')\n\n    // this click event causes the react lifecycle method componentDidUpdate\n    // to be called. There, we'll update the colors. (the props in this\n    // function body aren't up to date at that point)\n    circles.on('click', event => {\n      const selected_datum_i = parseInt(event.target.id)\n      setSelectedDatum(selected_datum_i)\n      selectCluster(labels![selected_datum_i].label_kmedoids)\n    })\n\n    // zoom behavior\n    this.zoomBehavior = this.getZoomBehavior(this.group)\n    this.svg.call(this.zoomBehavior)\n\n    // start with scaled up init view if first time, else take previours scale state\n    this.svg.call(this.zoomBehavior.transform, this.scaleTransform || this.getInitScale(width, height))\n\n    if (this.props.selectedCluster) this.updateColorPoints()\n  }\n\n  /**\n   * returns function which applies a transformation after each zoom\n   * event (that is, dragging around + zooming).\n   *\n   * @param selection is the selection of nodes which should be transformed\n   * @returns a zoomBehavior function, to be called on the node on which this behavior\n   * should be bound to.\n   */\n  getZoomBehavior (selection: d3.Selection<any | null, any, any | null, any | null>): ZoomBehavior<any, any> {\n    return d3.zoom().on('zoom', ({ transform }) => {\n      this.scaleTransform = transform\n      selection.attr('transform', transform)\n    })\n  }\n\n  /**\n   * @param {int} width the width of the surrounding svg container\n   * @param {int} height the height of the surrounding svg container\n   * @returns a zoom behavior function with a scale factor that scales\n   * the data to width and height\n   *\n   * NOTE: assumes that the scale defined in {Data.js} is [0,100]\n   */\n  getInitScale (width: number, height: number) {\n    const scaleFactor = Math.min(width / 100, height / 100) // factor to either fill horizontally or vertically\n    return d3.zoomIdentity.scale(scaleFactor)\n  }\n\n  componentDidMount () {\n    this.drawScatterPlot()\n  }\n\n  /**\n   * updates all points so that the clicked point and the points belonging\n   * to its cluster have distinct colors\n   */\n  updateColorPoints () {\n    const { selected_datum, labels, allCoordinatesAsArray } = this.props\n    if (!this.svg || !labels || !this.group) return\n\n    const coordsToShow = allCoordinatesAsArray\n    if (coordsToShow.length === 0) return this.svg.selectAll('circle').remove()\n\n    this.group.selectAll('circle')\n      .data(coordsToShow, ([,, index]) => index)\n      .attr('fill', ([,, index]) => {\n        if (index == selected_datum) return 'cyan'\n        if (this.props.selectedCluster == labels[index].label_kmedoids) return this.hoverColor // orange kinda\n        return 'white'\n      })\n  }\n\n  highlightSearchResults () {\n    if (!this.svg || !this.group) return\n    const { allCoordinatesAsArray, searchResultIndices } = this.props\n    const coordsToShow = allCoordinatesAsArray\n    if (coordsToShow.length === 0) return this.group.selectAll('circle').remove()\n\n    this.group.selectAll('circle')\n      .data(coordsToShow, ([,, index]) => index)\n      .attr('fill', ([,, index]) => {\n        if (searchResultIndices[index]) return this.hoverColor\n        return 'white'\n      })\n  }\n\n  /** highlights the comment the user hovers over in the detail pane */\n  showHoveredComment () {\n    const { labels, allCoordinatesAsArray, hoveredCommentCoordinate } = this.props\n    if (!this.svg || !labels || !this.group) return\n\n    const coordsToShow = allCoordinatesAsArray\n    if (coordsToShow.length === 0) return this.group.selectAll('circle').remove()\n\n    if (hoveredCommentCoordinate) coordsToShow.push([hoveredCommentCoordinate?.x, hoveredCommentCoordinate?.y, hoveredCommentCoordinate?.index])\n\n    this.group.selectAll('circle')\n      .data(coordsToShow, ([,, index]) => index)\n      .join(\n        enter => enter.append('circle')\n          .attr('fill', 'cyan')\n          .attr('fill-opacity', '1')\n          .attr('r', 1)\n          .attr('id', ([,, index]) => index)\n          .attr('cx', ([x]) => x)\n          .attr('cy', ([, y]) => y)\n      )\n  }\n\n  /** zooms around so that cluster center is in the center of svg viewport and all clusters are visible */\n  zoomAroundCluster () {\n    if (!this.zoomBehavior) return\n    if (!this.svg) return\n    if (!this.props.selectedCluster) { // if unselected cluster, show overview\n      const scaleFactor = this.getInitScale(this.props.width, this.props.height)\n\n      this.svg?.transition()\n        .duration(1000)\n        .call(\n          this.zoomBehavior.transform,\n          d3.zoomIdentity.scale(scaleFactor.k)\n        )\n      return\n    }\n\n    const numNeighbors = this.props.coordinatesParameters.numNeighborsParameter\n    const minDist = this.props.coordinatesParameters.minDistParameter\n    if (!this.props.allCoordinatesFull?.[numNeighbors]?.[minDist]) return\n\n    const allCoordsOfSelectedCluster = this.props.labels?.filter(\n      (el) => (el.label_kmedoids === this.props.selectedCluster))\n      .map((el, i) => this.props.allCoordinatesFull?.[numNeighbors]?.[minDist]?.[i]!)\n\n    const mean_x = _.meanBy(allCoordsOfSelectedCluster, 'x') || 15\n    const mean_y = _.meanBy(allCoordsOfSelectedCluster, 'y') || 15\n    // TODO max x and max y, min x and min y, then scale factor just like below\n    // position where mean point is in the center of viewport\n    const delta_x = _.maxBy(allCoordsOfSelectedCluster, 'x')?.x || 0 - (_.minBy(allCoordsOfSelectedCluster, 'x')?.x || 0)\n    const delta_y = _.maxBy(allCoordsOfSelectedCluster, 'y')?.y || 0 - (_.minBy(allCoordsOfSelectedCluster, 'y')?.y || 0)\n    const scaleFactor = Math.min(this.props.width / delta_x, this.props.height / delta_y)\n\n    this.svg?.transition()\n      .duration(500)\n      .call(\n        this.zoomBehavior.translateTo,\n        mean_x, mean_y\n      )\n      .transition()\n      .duration(500)\n      .call(\n        this.zoomBehavior.scaleTo,\n        scaleFactor * 1.3\n      )\n  }\n\n  hasCommentClickedOnChanged (prevProps: PropsForProjection) {\n    return prevProps.selected_datum !== this.props.selected_datum\n  }\n\n  haveCoordinatesChanged (prevProps: PropsForProjection) {\n    return !_.isEqual(_.sortBy(prevProps.allCoordinates), _.sortBy(this.props.allCoordinates))\n  }\n\n  haveSearchResultsChanged (prevProps: PropsForProjection) {\n    return prevProps.searchResultIndices !== this.props.searchResultIndices\n  }\n\n  haveClustersToShowChanged (prevProps: PropsForProjection) {\n    return !_.isEqual(_.sortBy(prevProps.clustersToShow), _.sortBy(this.props.clustersToShow))\n  }\n\n  hasSelectedClusterChanged (prevProps: PropsForProjection) {\n    return prevProps.selectedCluster !== this.props.selectedCluster\n  }\n\n  hasHoveredCommentCoordinateChanged (prevProps: PropsForProjection) {\n    return prevProps.hoveredCommentCoordinate?.index !== this.props.hoveredCommentCoordinate?.index\n  }\n\n  componentDidUpdate (prevProps: PropsForProjection, prevState: {}) {\n    if (this.hasCommentClickedOnChanged(prevProps)) {\n      this.updateColorPoints()\n      return\n    }\n    if (this.hasSelectedClusterChanged(prevProps)) {\n      this.drawScatterPlot()\n      this.zoomAroundCluster()\n      return\n    }\n    if (this.haveClustersToShowChanged(prevProps) || this.haveCoordinatesChanged(prevProps)) {\n      this.drawScatterPlot()\n      return\n    }\n    if (this.haveSearchResultsChanged(prevProps)) return this.highlightSearchResults()\n    if (this.hasHoveredCommentCoordinateChanged(prevProps)) return this.showHoveredComment()\n  }\n\n  render () {\n    const { width, height } = this.props\n    return (\n      <svg ref={(ref) => {\n        this.ref = ref\n      }} width={width} height={height} overflow=\"hidden\"></svg>\n    )\n  }\n}\n\nexport default Projection\n","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/ProjectionElements/ProjectionParameters.tsx",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/ProjectionElements/Sliders.tsx",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/index.js",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/ClusterDetailsLayout.tsx",["86","87","88","89","90","91"],"import React, { useState, useEffect, useRef } from 'react'\nimport { ChangedClusterName, DataPoint } from '../../Data'\nimport { PropsForSidebar } from '../../SidebarOverview'\nimport ClusterMenu from './ClusterMenu'\nimport Comment from './Comment'\nimport { makeStyles, Typography } from '@material-ui/core'\nimport _ from 'lodash'\nimport List from '@material-ui/core/List'\nimport ListItemComment from './ListItemComment'\n\nconst useStyles = makeStyles(theme => ({\n  padding: {\n    padding: theme.spacing(2)\n  },\n  coverSidebar: {\n    position: 'relative',\n    width: '100%',\n    height: '100vh',\n    overflow: 'scroll',\n    transition: 'all 0.3s',\n    backgroundColor: '#222'\n  },\n  root: {\n    width: '100%'\n  }\n}))\n\ntype ClusterDetailsLayoutProps = PropsForSidebar\n\nlet prevSelectedCluster: string | null = ''\nlet prevLabelLocal: string = ''\n\nexport default function ClusterDetailsLayout (props: ClusterDetailsLayoutProps) {\n  const { data, dataChanged, pushToDataChanged, labels, selected_datum, selectedCluster } = props\n  const classes = useStyles()\n  const clickedOnCommentRef = useRef<null | HTMLDivElement>(null)\n  const [labelLocal, _setLabelLocal] = useState(selectedCluster || '')\n  const setLabelLocal = (val: string) => {\n    prevLabelLocal = val\n    _setLabelLocal(val)\n\n    props.setChangedClusterName({\n      original: props.selectedCluster,\n      changed: val\n    } as ChangedClusterName)\n  }\n  // select only unchanged data of cluster, without selected point\n  const dataOfCluster = data!.filter((d, i) => {\n    if (labels === null) return false\n    const hasMovedAlready = _.find(dataChanged, ['i', d.i]) // undefined if not found\n    const isSelectedDatum = (i === selected_datum)\n    const sameCluster = (labels[i].label_kmedoids == selectedCluster)\n    return !hasMovedAlready && sameCluster && !isSelectedDatum\n  })\n\n  // select all data that was added to this cluster\n  const dataAddedToThisCluster = dataChanged.filter(el => el.newLabel.label_kmedoids === selectedCluster)\n  // select all data that was removed from this cluster\n  const dataRemovedFromThisCluster = dataChanged.filter(el => el.oldLabel.label_kmedoids === selectedCluster)\n\n  useEffect(() => { // if new point or cluster was clicked on, set to that\n    if (selectedCluster && prevSelectedCluster && prevSelectedCluster != prevLabelLocal) {\n      props.renameLabels([prevSelectedCluster], prevLabelLocal)\n    }\n\n    prevLabelLocal = labelLocal\n    prevSelectedCluster = selectedCluster\n  }, [selectedCluster])\n\n  useEffect(() => { // scroll to selected comment section if point was clicked on projection\n    if (clickedOnCommentRef.current) clickedOnCommentRef.current.scrollIntoView({ behavior: 'smooth' })\n  }, [selected_datum])\n\n  const onMoveCluster = (newLabel: string | null, i: number) => {\n    if (!newLabel || !labels) return\n    pushToDataChanged({\n      ...data![i],\n      oldLabel: labels[i],\n      newLabel: { label_kmedoids: newLabel }\n    })\n  }\n\n  /**\n     *\n     * @param data\n     * @param type \"normal\" | \"added\" | \"removed\"\n     */\n  const buildComments = (data: DataPoint[], type: 'normal' | 'added' | 'removed') => {\n    return data.map((element, index) => {\n      // eslint-disable-next-line array-callback-return\n      if (index > 20) return\n      return (\n                <Comment onMoveCluster={onMoveCluster} i={element.i} key={`cluster-peer-${index}`}\n                    {...type === 'added' ? { added: true } : type === 'removed' ? { removed: true } : {}}\n                    {...props} dense />\n      )\n    })\n  }\n\n  const buildHeadlineAndInfo = (headline: string, caption: string | null) => (\n        <div className={classes.padding}>\n            <Typography variant='h5'>{headline}</Typography>\n            {caption &&\n                <Typography variant=\"body2\">{caption}</Typography>\n            }\n        </div>\n  )\n\n  const hasRepresentative = props.selectedCluster && props.clusters[props.selectedCluster]?.medoid\n  const otherRepresentatives = props.selectedCluster && props.clusters[props.selectedCluster]?.representatives.length > 0\n\n  return (\n    (selectedCluster)\n      ? (<>\n                <div ref={clickedOnCommentRef}></div>\n                <ClusterMenu labelLocal={labelLocal!} setLabelLocal={setLabelLocal} {...props} />\n                {dataAddedToThisCluster.length != 0 && buildHeadlineAndInfo('Added to this Cluster', 'Here are all comments added to this cluster from another by you in this cycle.')}\n                {dataAddedToThisCluster.length != 0 && buildComments(dataAddedToThisCluster as DataPoint[], 'added')}\n                {dataRemovedFromThisCluster.length != 0 && buildHeadlineAndInfo('Removed from this Cluster', 'Here are all comments removed from this cluster by you in this cycle.')}\n                {dataRemovedFromThisCluster.length != 0 && buildComments(dataRemovedFromThisCluster as DataPoint[], 'removed')}\n                {selected_datum && (\n                    <>\n                        {buildHeadlineAndInfo('Selected Comment', 'The comment of the point clicked on.')}\n                        <Comment onMoveCluster={onMoveCluster} i={selected_datum} {...props} />\n                    </>\n                )}\n                {hasRepresentative && buildHeadlineAndInfo('Cluster Representative', 'The comment best representing all other comments of this cluster.')}\n                {hasRepresentative && <Comment onMoveCluster={onMoveCluster} isRepresentative i={props.clusters[props.selectedCluster!].medoid || 0} {...props} />}\n                {otherRepresentatives && buildHeadlineAndInfo('Overview Comments', 'Distinct comments of this cluster, representing different sub-topics of this cluster.')}\n                {otherRepresentatives && props.clusters[props.selectedCluster!].representatives.map(\n                  reprs_index => (\n                        <Comment key={`representative-${reprs_index}`} onMoveCluster={onMoveCluster} i={reprs_index} {...props} />\n                  )\n                )}\n                {buildHeadlineAndInfo('Other Comments', 'A sample of other comments of this cluster.')}\n                <List className={classes.root}>\n                    {dataOfCluster.slice(0, 20).map((d: DataPoint) =>\n                      (<ListItemComment d={d} i={d.i} onMoveCluster={onMoveCluster} key={`list comment ${d.i}`} {...props}/>)\n                    )}\n                </List>\n            </>)\n      : <div className={classes.coverSidebar} style={{ display: 'flex', justifyContent: 'center', alignItems: 'center' }}>\n                <Typography style={{ padding: 16 }}>Click on a point or on a cluster in the left panel to see its details here!</Typography>\n            </div>\n  )\n}\n","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterOverview/ClusterTable.tsx",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/ListItemComment.tsx",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/Comment.tsx",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/ClusterMenu.tsx",[],[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/ClusterChangeCommentDialog.tsx",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/App.tsx",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarOverview.tsx",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarDetails.tsx",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterOverview/ClusterMerger.tsx",["92","93"],"import { Button, makeStyles, TextField } from '@material-ui/core'\nimport Autocomplete from '@material-ui/lab/Autocomplete'\nimport React, { useState } from 'react'\nimport { PropsForSidebar } from '../../SidebarOverview'\n\nconst useStyles = makeStyles((theme) => ({\n  horizontalContainer: {\n    paddingRight: theme.spacing(3),\n    paddingLeft: theme.spacing(3),\n    paddingTop: '1em',\n    paddingBottom: '1em',\n    width: 'auto',\n    height: 'auto'\n  },\n  rightAlign: {\n    display: 'block',\n    marginLeft: 'auto',\n    marginRight: '0'\n  },\n  gridContainer: {\n    display: 'grid',\n    gridTemplateColumns: '9fr 1fr',\n    gridRowGap: theme.spacing(1)\n  }\n}))\n\nexport default function ClusterMerger (props: PropsForSidebar) {\n  const classes = useStyles()\n  const [newClusterName, setName] = useState('New Cluster Name')\n  const [firstLabel, setFirstLabel] = useState<string | null>(null)\n  const [secondLabel, setSecondLabel] = useState<string | null>(null)\n\n  const allClusters = Array.from(new Set(props.labels?.map(label => label.label_kmedoids)))\n\n  const merge = () => {\n    if (!firstLabel || !secondLabel) return\n    props.renameLabels([firstLabel, secondLabel], newClusterName)\n    props.setSelectedDatum(null)\n    props.selectCluster(newClusterName)\n    if (!props.clustersToShow.includes(newClusterName)) {\n      props.setClustersToShow([...props.clustersToShow, newClusterName])\n    }\n    setFirstLabel(null)\n    setSecondLabel(null)\n  }\n\n  const groupByVisibleClusters = (option: string) =>\n    (props.clustersToShow?.includes(option))\n      ? 'Visible Clusters'\n      : 'Other Clusters'\n\n  /** comparator to sort array by its visibility in the projection */\n  const compareByVisibility = (a: string, b: string) => {\n    const aGroup = groupByVisibleClusters(a)\n    const bGroup = groupByVisibleClusters(b)\n    if (aGroup < bGroup) return 1\n    else if (aGroup === bGroup) return 0\n    else return -1 // (aGroup > bGroup)\n  }\n\n  return (\n        <>\n            <div className={classes.gridContainer}>\n                <Autocomplete\n                    options={allClusters.filter(cluster => cluster != secondLabel).sort(compareByVisibility)}\n                    groupBy={groupByVisibleClusters}\n                    renderInput={(params: any) => <TextField {...params} label=\"First\" variant=\"outlined\" />}\n                    onChange={(e, value) => setFirstLabel(value!)}\n                    value={firstLabel}\n                />\n                <p style={{ textAlign: 'center' }}>+</p>\n                <Autocomplete\n                    options={allClusters.filter(cluster => cluster != firstLabel).sort(compareByVisibility)}\n                    groupBy={groupByVisibleClusters}\n                    renderInput={(params: any) => <TextField {...params} label=\"Second\" variant=\"outlined\" />}\n                    onChange={(e, value) => setSecondLabel(value!)}\n                    value={secondLabel}\n                />\n                <p style={{ textAlign: 'center' }}>=</p>\n                <TextField\n                    variant='outlined'\n                    value={newClusterName}\n                    onChange={(e) => setName(e.target.value)}\n                />\n            </div>\n            <div className={classes.horizontalContainer}>\n                <Button\n                    className={classes.rightAlign}\n                    variant=\"contained\"\n                    color=\"primary\"\n                    onClick={merge}\n                    disabled={!(firstLabel && secondLabel)}\n                >Merge</Button>\n            </div>\n        </>\n  )\n}\n","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterOverview/ClustersOverview.tsx",[],{"ruleId":"94","severity":1,"message":"95","line":197,"column":91,"nodeType":"96","messageId":"97","endLine":197,"endColumn":93},{"ruleId":"94","severity":1,"message":"95","line":198,"column":74,"nodeType":"96","messageId":"97","endLine":198,"endColumn":76},{"ruleId":"94","severity":1,"message":"95","line":240,"column":20,"nodeType":"96","messageId":"97","endLine":240,"endColumn":22},{"ruleId":"94","severity":1,"message":"98","line":510,"column":63,"nodeType":"96","messageId":"97","endLine":510,"endColumn":65},{"ruleId":"94","severity":1,"message":"95","line":155,"column":19,"nodeType":"96","messageId":"97","endLine":155,"endColumn":21},{"ruleId":"94","severity":1,"message":"95","line":156,"column":40,"nodeType":"96","messageId":"97","endLine":156,"endColumn":42},{"ruleId":"94","severity":1,"message":"95","line":52,"column":51,"nodeType":"96","messageId":"97","endLine":52,"endColumn":53},{"ruleId":"94","severity":1,"message":"98","line":62,"column":71,"nodeType":"96","messageId":"97","endLine":62,"endColumn":73},{"ruleId":"94","severity":1,"message":"98","line":117,"column":48,"nodeType":"96","messageId":"97","endLine":117,"endColumn":50},{"ruleId":"94","severity":1,"message":"98","line":118,"column":48,"nodeType":"96","messageId":"97","endLine":118,"endColumn":50},{"ruleId":"94","severity":1,"message":"98","line":119,"column":52,"nodeType":"96","messageId":"97","endLine":119,"endColumn":54},{"ruleId":"94","severity":1,"message":"98","line":120,"column":52,"nodeType":"96","messageId":"97","endLine":120,"endColumn":54},{"ruleId":"94","severity":1,"message":"98","line":65,"column":68,"nodeType":"96","messageId":"97","endLine":65,"endColumn":70},{"ruleId":"94","severity":1,"message":"98","line":73,"column":68,"nodeType":"96","messageId":"97","endLine":73,"endColumn":70},"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='."]