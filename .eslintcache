[{"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/index.js":"1","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/App.js":"2","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/serviceWorker.js":"3","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/About.js":"4","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Content.js":"5","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/Separator.js":"6","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/Select.js":"7","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Store.js":"8","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterOverview/ClusterSnippet.js":"9","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/index.js":"10","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/ClusterDetailsLayout.tsx":"11","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Data.tsx":"12","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Layout.tsx":"13","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Sidebar.tsx":"14","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterOverview/ClusterOverview.tsx":"15","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterOverview/ClusterTable.tsx":"16","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/ClusterMenu.tsx":"17","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/MetaInfo.tsx":"18","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/NeoMorphCard.tsx":"19","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterMerger.tsx":"20","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/ProjectionElements/Projection.tsx":"21","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/ProjectionElements/ProjectionParameters.tsx":"22","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/ProjectionElements/Sliders.tsx":"23","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/Comment.tsx":"24","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/ClusterChangeCommentDialog.tsx":"25","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Sidebar2.tsx":"26","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/ListItemComment.tsx":"27"},{"size":451,"mtime":1607874062990,"results":"28","hashOfConfig":"29"},{"size":1061,"mtime":1615936830110,"results":"30","hashOfConfig":"29"},{"size":4948,"mtime":1607874062991,"results":"31","hashOfConfig":"29"},{"size":1570,"mtime":1607874062988,"results":"32","hashOfConfig":"33"},{"size":9278,"mtime":1607874062988,"results":"34","hashOfConfig":"33"},{"size":519,"mtime":1609349848460,"results":"35","hashOfConfig":"33"},{"size":753,"mtime":1609877020615,"results":"36","hashOfConfig":"33"},{"size":978,"mtime":1610638122448,"results":"37","hashOfConfig":"33"},{"size":1563,"mtime":1610662485820,"results":"38","hashOfConfig":"33"},{"size":185,"mtime":1611271763856,"results":"39","hashOfConfig":"29"},{"size":7252,"mtime":1620295789133,"results":"40","hashOfConfig":"29"},{"size":19496,"mtime":1620295978699,"results":"41","hashOfConfig":"29"},{"size":7128,"mtime":1616366727426,"results":"42","hashOfConfig":"29"},{"size":906,"mtime":1616366879904,"results":"43","hashOfConfig":"29"},{"size":4622,"mtime":1616443145635,"results":"44","hashOfConfig":"29"},{"size":13537,"mtime":1620293460314,"results":"45","hashOfConfig":"29"},{"size":1551,"mtime":1616367180698,"results":"46","hashOfConfig":"29"},{"size":1277,"mtime":1612014720566,"results":"47","hashOfConfig":"33"},{"size":904,"mtime":1611278770069,"results":"48","hashOfConfig":"33"},{"size":3716,"mtime":1613586619846,"results":"49","hashOfConfig":"29"},{"size":10837,"mtime":1616366919498,"results":"50","hashOfConfig":"29"},{"size":2989,"mtime":1616256661649,"results":"51","hashOfConfig":"29"},{"size":4654,"mtime":1620294986506,"results":"52","hashOfConfig":"29"},{"size":4684,"mtime":1620252327020,"results":"53","hashOfConfig":"29"},{"size":3872,"mtime":1614009016789,"results":"54","hashOfConfig":"29"},{"size":1229,"mtime":1616367118027,"results":"55","hashOfConfig":"29"},{"size":3402,"mtime":1620252296623,"results":"56","hashOfConfig":"29"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"59"},"qr1yfr",{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"59"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"59"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"66","usedDeprecatedRules":"67"},"mxeu8k",{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"67"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"72"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"67"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"77","messages":"78","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"79","usedDeprecatedRules":"67"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"59"},{"filePath":"82","messages":"83","errorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":0,"source":"84","usedDeprecatedRules":"85"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"88","usedDeprecatedRules":"85"},{"filePath":"89","messages":"90","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"91","usedDeprecatedRules":"85"},{"filePath":"92","messages":"93","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"85"},{"filePath":"94","messages":"95","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"96","usedDeprecatedRules":"85"},{"filePath":"97","messages":"98","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"99","usedDeprecatedRules":"85"},{"filePath":"100","messages":"101","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"102","usedDeprecatedRules":"85"},{"filePath":"103","messages":"104","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"105","usedDeprecatedRules":"106"},{"filePath":"107","messages":"108","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"109","usedDeprecatedRules":"110"},{"filePath":"111","messages":"112","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"113","usedDeprecatedRules":"85"},{"filePath":"114","messages":"115","errorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"116","usedDeprecatedRules":"85"},{"filePath":"117","messages":"118","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"119","usedDeprecatedRules":"85"},{"filePath":"120","messages":"121","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"85"},{"filePath":"122","messages":"123","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"124","usedDeprecatedRules":"85"},{"filePath":"125","messages":"126","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"127"},{"filePath":"128","messages":"129","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"85"},{"filePath":"130","messages":"131","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"132","usedDeprecatedRules":"85"},"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/index.js",[],["133","134"],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/App.js",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/serviceWorker.js",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/About.js",["135"],"import React, { Component } from 'react'\nimport Markdown from 'react-remarkable'\nimport { about_text } from './Content'\n\nclass About extends Component {\n  render() {\n    let { grem, p } = this.props\n    return (\n      <div\n        style={{\n          position: 'fixed',\n          left: 0,\n          top: 0,\n          right: 0,\n          bottom: 0,\n          background: '#222',\n          color: '#fff',\n          paddingTop: grem * 2,\n          overflowY: 'auto',\n          fontSize: 16,\n          lineHeight: 1.5,\n        }}\n      >\n        <div\n          style={{\n            background: '#333',\n            position: 'fixed',\n            left: 0,\n            top: 0,\n            right: 0,\n            padding: grem / 2,\n          }}\n        >\n          About\n          <button\n            onClick={() => {\n              this.props.toggleAbout(false)\n            }}\n            className=\"hover-555\"\n            style={{\n              position: 'absolute',\n              right: 0,\n              top: 0,\n              height: grem * 2,\n              width: grem * 2,\n              padding: grem / 2,\n              textAlign: 'center',\n              cursor: 'pointer',\n              textDecoration: 'none',\n            }}\n          >\n            &times;\n          </button>\n        </div>\n        <div\n          style={{\n            maxWidth: grem * 30,\n            margin: '0 auto',\n            padding: grem / 2,\n            color: '#fff',\n          }}\n        >\n          <Markdown>{about_text}</Markdown>\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default About\n",["136","137"],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Content.js",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/Separator.js",[],["138","139"],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/Select.js",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Store.js",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterOverview/ClusterSnippet.js",["140"],"import React from 'react';\nimport { createUseStyles } from 'react-jss'\n\nconst useStyles = createUseStyles(\n    {\n        card: {\n            display: 'block',\n            margin: '32px 24px',\n            padding: '4px 16px',\n            position: 'relative',\n            transition: 'all .2s ease-in-out',\n            '&:hover': {\n                boxShadow: '0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)',\n                marginBottom: '54px'\n            }\n        },\n        neomorphism: {\n            borderRadius: '15px',\n            background: 'linear-gradient(145deg, #373737, #2e2e2e)',\n            boxShadow: '5px 5px 12px #181818, -5px -5px 12px #4e4e4e'\n        },\n        p: {\n            display: 'inline-block',\n            marginBlockStart: '1em',\n            marginBlockEnd: '1em',\n            marginInlineStart: '0px',\n            marginInlineEnd: '1em',\n        },\n    })\n\n/**\n * \n * @param comments is the subset of the data which has label @param label\n * @param label is the label of said comments\n */\nexport default function ClusterSnippet({ label, labels, data, ...otherProps }) {\n    const classes = useStyles()\n\n    const correctLabels = labels.filter(({ label_kmedoids, label_kmeans }) => label_kmedoids === label)\n    const size = correctLabels.length\n\n    const onClick = (e) => null\n\n    return (\n\n        <div className={`${classes.neomorphism} ${classes.card}`}>\n            <h3>{label}</h3>\n            <p className={classes.p}>Size: {size}</p>\n            <p className={classes.p}>Density: 41</p>\n        </div>\n    )\n}","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/index.js",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/ClusterDetailsLayout.tsx",["141","142","143","144","145","146","147","148","149","150","151","152","153","154","155","156","157","158","159","160","161"],"import React, { useState, useEffect, useRef } from 'react'\nimport { ChangedClusterName, DataPoint, Label } from '../../Data'\nimport { PropsForSidebar } from '../../Sidebar'\nimport Separator from '../Separator'\nimport ClusterMenu from './ClusterMenu'\nimport MetaInfo from './MetaInfo'\nimport Comment from './Comment'\nimport NeoMorphCard from './NeoMorphCard'\nimport { Box, Card, CardContent, ListItem, ListItemSecondaryAction, makeStyles, Typography } from '@material-ui/core'\nimport ClusterChangeCommentDialog from './ClusterChangeCommentDialog'\nimport _ from 'lodash'\nimport { index } from 'd3'\nimport List from '@material-ui/core/List'\nimport ListItemText from '@material-ui/core/ListItemText'\nimport Divider from '@material-ui/core/Divider'\nimport ListItemComment from './ListItemComment'\n\n\nconst useStyles = makeStyles(theme => ({\n    padding: {\n        padding: theme.spacing(2),\n    },\n    coverSidebar: {\n        position: 'relative',\n        width: '100%',\n        height: '100vh',\n        overflow: 'scroll',\n        transition: 'all 0.3s',\n        backgroundColor: '#222'\n    },\n    root: {\n        width: '100%',\n    },\n}))\n\ntype ClusterDetailsLayoutProps = PropsForSidebar\n\nlet prevSelectedCluster: string | null = \"\"\nlet prevLabelLocal: string = \"\"\n\nexport default function ClusterDetailsLayout(props: ClusterDetailsLayoutProps) {\n    const { data, dataChanged, pushToDataChanged, labels, selected_datum, selectedCluster } = props\n    const classes = useStyles()\n    const clickedOnCommentRef = useRef<null | HTMLDivElement>(null)\n    const [labelLocal, _setLabelLocal] = useState(selectedCluster || \"\")\n    const setLabelLocal = (val: string) => {\n        prevLabelLocal = val\n        _setLabelLocal(val)\n\n        props.setChangedClusterName({\n            original: props.selectedCluster,\n            changed: val\n        } as ChangedClusterName)\n    }\n    // select only unchanged data of cluster, without selected point\n    const dataOfCluster = data!.filter((d, i) => {\n        if (labels === null) return false\n        const hasMovedAlready = _.find(dataChanged, ['i', d.i]) // undefined if not found\n        const isSelectedDatum = (i === selected_datum)\n        const sameCluster = (labels[i].label_kmedoids == selectedCluster)\n        return !hasMovedAlready && sameCluster && !isSelectedDatum\n    })\n\n    // select all data that was added to this cluster\n    const dataAddedToThisCluster = dataChanged.filter(el => el.newLabel.label_kmedoids === selectedCluster)\n    // select all data that was removed from this cluster\n    const dataRemovedFromThisCluster = dataChanged.filter(el => el.oldLabel.label_kmedoids === selectedCluster)\n\n    useEffect(() => { // if new point or cluster was clicked on, set to that\n        if (selectedCluster && prevSelectedCluster && prevSelectedCluster != prevLabelLocal) {\n            props.renameLabels([prevSelectedCluster], prevLabelLocal)\n        }\n\n        prevLabelLocal = labelLocal\n        prevSelectedCluster = selectedCluster\n    }, [selectedCluster])\n\n    useEffect(() => { // scroll to selected comment section if point was clicked on projection \n        if (clickedOnCommentRef.current) clickedOnCommentRef.current.scrollIntoView({ behavior: 'smooth' })\n    }, [selected_datum])\n\n    const onMoveCluster = (newLabel: string | null, i: number) => {\n        if (!newLabel || !labels) return\n        pushToDataChanged({\n            ...data![i],\n            oldLabel: labels[i],\n            newLabel: { label_kmedoids: newLabel }\n        })\n    }\n\n    /**\n     * \n     * @param data \n     * @param type \"normal\" | \"added\" | \"removed\"\n     */\n    const buildComments = (data: DataPoint[], type: 'normal' | \"added\" | \"removed\") => {\n        return data.map((element, index) => {\n            if (index > 20) return\n            return (\n                <Comment onMoveCluster={onMoveCluster} i={element.i} key={`cluster-peer-${index}`}\n                    {...type === 'added' ? { added: true } : type === 'removed' ? { removed: true } : {}}\n                    {...props} dense />\n            )\n        })\n    }\n\n    const buildHeadlineAndInfo = (headline: string, caption: string | null) => (\n        <div className={classes.padding}>\n            <Typography variant='h5'>{headline}</Typography>\n            {caption &&\n                <Typography variant=\"body2\">{caption}</Typography>\n            }\n        </div>\n    )\n\n    const hasRepresentative = props.selectedCluster && props.clusters[props.selectedCluster]?.medoid\n    const otherRepresentatives = props.selectedCluster && props.clusters[props.selectedCluster]?.representatives.length > 0\n\n    return (\n        (selectedCluster) ?\n            (<>\n                <div ref={clickedOnCommentRef}></div>\n                <ClusterMenu labelLocal={labelLocal!} setLabelLocal={setLabelLocal} {...props} />\n                {dataAddedToThisCluster.length != 0 && buildHeadlineAndInfo('Added to this Cluster', 'Here are all comments added to this cluster from another by you in this cycle.')}\n                {dataAddedToThisCluster.length != 0 && buildComments(dataAddedToThisCluster as DataPoint[], 'added')}\n                {dataRemovedFromThisCluster.length != 0 && buildHeadlineAndInfo('Removed from this Cluster', 'Here are all comments removed from this cluster by you in this cycle.')}\n                {dataRemovedFromThisCluster.length != 0 && buildComments(dataRemovedFromThisCluster as DataPoint[], 'removed')}\n                {selected_datum && (\n                    <>\n                        {buildHeadlineAndInfo('Selected Comment', 'The comment of the point clicked on.')}\n                        <Comment onMoveCluster={onMoveCluster} i={selected_datum} {...props} />\n                    </>\n                )}\n                {hasRepresentative && buildHeadlineAndInfo('Cluster Representative', 'The comment best representing all other comments of this cluster.')}\n                {hasRepresentative && <Comment onMoveCluster={onMoveCluster} isRepresentative i={props.clusters[props.selectedCluster!].medoid || 0} {...props} />}\n                {otherRepresentatives && buildHeadlineAndInfo('Overview Comments', 'Distinct comments of this cluster, representing different sub-topics of this cluster.')}\n                {otherRepresentatives && props.clusters[props.selectedCluster!].representatives.map(\n                    reprs_index => (\n                        <Comment key={`representative-${reprs_index}`} onMoveCluster={onMoveCluster} i={reprs_index} {...props} />\n                    )\n                )}\n                {buildHeadlineAndInfo('Other Comments', 'A sample of other comments of this cluster.')}\n                <List className={classes.root}>\n                    {dataOfCluster.slice(0, 20).map((d: DataPoint) => \n                        (<ListItemComment d={d} i={d.i} onMoveCluster={onMoveCluster} key={`list comment ${d.i}`} {...props}/>)\n                    )}\n                </List>\n            </>)\n            : <div className={classes.coverSidebar} style={{ display: 'flex', justifyContent: 'center', alignItems: 'center' }}>\n                <Typography style={{ padding: 16 }}>Click on a point or on a cluster in the left panel to see its details here!</Typography>\n            </div>\n    )\n}",["162","163"],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Data.tsx",["164","165","166","167","168","169","170","171","172","173"],"import { constants } from 'buffer'\nimport * as d3 from 'd3'\nimport * as _ from 'lodash'\nimport lunr from 'lunr'\nimport React, { Component } from 'react'\nimport Layout from './Layout'\n\n\nexport type Coordinate = {\n  x: number,\n  y: number,\n  index: number\n}\n\nexport const min_dists_arr: string[] = ['0.1', '0.2', '0.5', '0.9']\nexport type ParameterMinDist = '0.1' | '0.2' | '0.5' | '0.9'\nexport type MinDist = {\n  '0.1': Coordinate[] | null,\n  '0.2': Coordinate[] | null,\n  '0.5': Coordinate[] | null,\n  '0.9': Coordinate[] | null,\n  [i: string]: Coordinate[] | null\n}\n\nexport const num_neighbors_arr: string[] = ['2', '5', '10', '50']\nexport type ParameterNumNeighbors = '2' | '5' | '10' | '50'\nexport type NumNeighbors = {\n  '2': MinDist,\n  '5': MinDist,\n  '10': MinDist,\n  '50': MinDist,\n  [i: string]: MinDist\n}\n\n/** used to keep track of changed label */\nexport type DataChanged = {\n  oldLabel: Label\n  newLabel: Label\n} & DataPoint\n\nexport type DataPoint = {\n  publishedAt: string,\n  authorName: string,\n  isReply: number,\n  text: string | null,\n  cleaned: string,\n  i: number\n}\n\nexport type Label = {\n  label_kmedoids: string\n}\n\nexport type ClusterInfo = {\n  /**is the index of the medoid of that data point.\n   * medoid might be null for newly created clusters.\n  */\n  medoid: number | null,\n  /**are the indices of representatives of this cluster */\n  representatives: number[],\n  size: number,\n  quality: number\n}\n\nexport type Cluster = {\n  [cluster: string]: ClusterInfo\n}\n\nexport type ChangedClusterName = {\n  original: String,\n  changed: String\n}\n\ntype State = {\n  /** this has actually all coordinates, unlike allCoordinates,\n   * which has a sample for all parameters */\n  allCoordinatesFull: NumNeighbors | null,\n  /** samples to show of selected coordinate parameters */\n  allCoordinates: Coordinate[] | null,\n  /** true iff coordinates are reloading */\n  coordsAreReloading: boolean,\n  coordinatesParameters: {\n    numNeighborsParameter: ParameterNumNeighbors,\n    minDistParameter: ParameterMinDist,\n  }\n  coordinates_to_show: number, // i.e. all svg circles to show\n  data: DataPoint[] | null,\n  /** data that was moved between clusters */\n  dataChanged: DataChanged[]\n  labels: Label[] | null,\n  searchIndex: lunr.Index | null,\n  /** is an array of cluster names to show on the projection */\n  clustersToShow: string[],\n  /** meta info about each cluster in a dictionary */\n  clusters: Cluster,\n  /** the coordinate of the comment the user hovers over, or null if not hovering */\n  hoveredCommentCoordinate: Coordinate | null,\n  /** the copy of the original cluster name and the current local change */\n  changedClusterName: ChangedClusterName | null\n}\n\nexport type PropsFromData = {\n  /** reloads newSize many coordinates that will be shown in Projection  */\n  reloadCoordinatesWithSize: (newSize: number, callback?: () => void) => void,\n  setSelectedCoordinates: (numNeighbors: ParameterNumNeighbors, minDist: ParameterMinDist) => void,\n  /**\n   * \n   * @param clusters is an array of labels of the clusters to show\n   */\n  setClustersToShow: (clusters: string[], callback?: () => void) => void,\n  /**\n   * changes all occurences of oldLabel to newLabel inside labels and\n   * clustersToShow.\n   * Make sure to handle all lower lying variables, e.g. selectedCluster,\n   * yourself.\n   * @param oldLabels\n   * @param newLabel \n   */\n  renameLabels: (oldLabels: string[], newLabel: string) => void,\n  /** \n   * adds new entry to dataChanged\n   * if entry with same i property already exists, then first remove that.\n   * if oldlabel is the same as newlabel, then remove and don't add\n   * updates clusters state too\n   */\n  pushToDataChanged: (newDataChange: DataChanged) => void,\n  /**\n   * sets hoveredCommentCoordinate to the coordinate associated with\n   * comment_index, or null of comment_index is null\n   */\n  setHoveredCommentCoordinate: (comment_index: number | null) => void,\n  /** set changedClusterName, i.e. object which keeps track of the local\n   * changes of a cluster name.\n   * \n   * Reset whenever a different cluster is selected.\n   */\n  setChangedClusterName: (changedClusterName: ChangedClusterName) => void,\n  [key: string]: any,\n} & State\n\n\nexport default class Data extends Component<any, State> {\n  random_indices: number[] | null = null\n\n  constructor(props: any) {\n    super(props)\n    this.state = {\n      allCoordinatesFull: null,\n      allCoordinates: null,\n      coordsAreReloading: false,\n      coordinatesParameters: {\n        numNeighborsParameter: '10',\n        minDistParameter: '0.1'\n      },\n      coordinates_to_show: 500,\n      data: null,\n      labels: null,\n      searchIndex: null,\n      clustersToShow: Array.from(Array(40).keys()).map(n => `cluster ${n}`),\n      clusters: {},\n      dataChanged: [],\n      hoveredCommentCoordinate: null,\n      changedClusterName: null,\n    }\n    this.reloadCoordinatesWithSize = this.reloadCoordinatesWithSize.bind(this)\n    this.setSelectedCoordinates = this.setSelectedCoordinates.bind(this)\n    this.setClustersToShow = this.setClustersToShow.bind(this)\n    this.renameLabels = this.renameLabels.bind(this)\n    this.pushToDataChanged = this.pushToDataChanged.bind(this)\n    this.setHoveredCommentCoordinate = this.setHoveredCommentCoordinate.bind(this)\n    this.setChangedClusterName = this.setChangedClusterName.bind(this)\n  }\n\n\n  setChangedClusterName(changedClusterName: ChangedClusterName) {\n    this.setState({\n      changedClusterName: changedClusterName\n    })\n  }\n\n\n  setHoveredCommentCoordinate(comment_index: number | null) {\n    if (!comment_index) {\n      this.setState({\n        hoveredCommentCoordinate: null\n      })\n      return\n    }\n    if (!this.state.allCoordinatesFull) return\n    const allComments = this.state.allCoordinatesFull[this.state.coordinatesParameters.numNeighborsParameter][this.state.coordinatesParameters.minDistParameter]\n    this.setState({\n      hoveredCommentCoordinate: allComments![comment_index]\n    })\n  }\n\n  pushToDataChanged(newData: DataChanged) {\n    let alreadyExisting = _.find(this.state.dataChanged, ['i', newData.i])\n    let newDataChanged = _.without(this.state.dataChanged, alreadyExisting)\n    if (!(\n      alreadyExisting && alreadyExisting.oldLabel.label_kmedoids == newData.newLabel.label_kmedoids // if users reverts change, skip\n      || !alreadyExisting && newData.oldLabel.label_kmedoids == newData.newLabel.label_kmedoids // if wasnt changed before but has no change either, skip\n    )) newDataChanged.push(newData)\n\n    // if new cluster, set clusters\n    if (!this.state.clusters[newData.newLabel.label_kmedoids]) {\n      let copy = { ...this.state.clusters }\n      copy[newData.newLabel.label_kmedoids] = {\n        medoid: null,\n        representatives: [],\n        size: 1,\n        quality: -1,\n      }\n      this.setState({\n        clusters: copy\n      })\n    }\n\n    this.setState({\n      dataChanged: newDataChanged as DataChanged[]\n    })\n  }\n\n  renameLabels(oldLabels: string[], newLabel: string) {\n    // rename in clusterToShow\n    const newClustersToShow = this.state.clustersToShow.map(\n      (el, i) => oldLabels.includes(el) ? newLabel : el\n    )\n\n    // rename in labels\n    const labels_new = this.state.labels!.map(\n      (label) => {\n        if (oldLabels.includes(label.label_kmedoids)) {\n          return { label_kmedoids: newLabel } as Label\n        }\n        return label\n      }\n    )\n\n    // rename in clusters\n    let clusters_new: Cluster = _.cloneDeep(this.state.clusters)\n    let didMerge = false\n    for (const oldLabel of oldLabels) {\n\n      if (oldLabel == newLabel) continue // skip merging if both already have same label\n\n      const isMerging = clusters_new[newLabel]\n      if (isMerging) { // merge if new already exists\n        didMerge = true\n        clusters_new[newLabel] = {\n          medoid: clusters_new[newLabel].medoid,\n          representatives: [...clusters_new[oldLabel].representatives, ...clusters_new[newLabel].representatives],\n          size: clusters_new[oldLabel].size + clusters_new[newLabel].size,\n          quality: -1\n        }\n      } else { // rename else\n        clusters_new[newLabel] = { ...this.state.clusters[oldLabel] }\n      }\n      delete clusters_new[oldLabel]\n    }\n\n    // rename in dataChanged\n    let dataChanged_new = this.state.dataChanged.map(el => // change 'from' field\n      (oldLabels.includes(el.oldLabel.label_kmedoids))\n        ? { ...el, oldLabel: { label_kmedoids: newLabel } }\n        : el\n    ).map(el => // change 'to' field\n      (oldLabels.includes(el.newLabel.label_kmedoids))\n        ? { ...el, newLabel: { label_kmedoids: newLabel } }\n        : el\n    )\n\n    this.setState({\n      clustersToShow: newClustersToShow,\n      labels: labels_new,\n      clusters: clusters_new,\n      dataChanged: dataChanged_new\n    }, () => {\n      if (didMerge) this.calc_quality()\n    })\n  }\n\n\n  /** updates coordinates of current points to updated coordinate parameters.\n   * Call this function after changing the coordinate parameters\n   * \n   * @param callback is called after allCoordinates is set\n   * \n   * @pre this.state.allCoordinates !== null\n   */\n  updateSelectedCoordinates(callback?: () => void) {\n    if (!this.state.allCoordinatesFull) throw Error(\"allCoordinates is null\")\n\n    const numNeighbors = this.state.coordinatesParameters.numNeighborsParameter\n    const minDist = this.state.coordinatesParameters.minDistParameter\n\n    let coordinates\n    if (!this.state.allCoordinates) {\n      const randIndices = this.getRandomIndices(this.state.labels || [], this.state.coordinates_to_show)\n      coordinates = randIndices.map(i => this.state.allCoordinatesFull![numNeighbors][minDist]![i])\n    } else {\n      // take same points and update coordinates\n      // this allows for nice transitions as the points remain the same\n      coordinates = this.state.allCoordinates!.map(i => this.state.allCoordinatesFull![numNeighbors][minDist]![i.index])\n    }\n\n    this.setState({\n      allCoordinates: coordinates,\n    }, callback)\n  }\n\n\n  setClustersToShow(clusters: string[], callback?: () => void) {\n    this.setState({\n      clustersToShow: clusters\n    })\n  }\n\n  /** unlike getSelectedCoordinates, this returns all coordinates,\n   * not only a sample\n   */\n  _getAllSelectedCoordinates() {\n    if (!this.state.allCoordinatesFull) {\n      console.log('allCoordinatesFull is null')\n      return []\n    }\n    const numNeighbors = this.state.coordinatesParameters.numNeighborsParameter\n    const minDist = this.state.coordinatesParameters.minDistParameter\n    return this.state.allCoordinatesFull[numNeighbors][minDist] || []\n  }\n\n  setSelectedCoordinates(numNeighbors: ParameterNumNeighbors, minDist: ParameterMinDist) {\n    this.setState({\n      coordinatesParameters: {\n        numNeighborsParameter: numNeighbors,\n        minDistParameter: minDist\n      }\n    }, this.updateSelectedCoordinates) // then update svg points\n  }\n\n  /**\n   * scales embeddings to values between [0, 10]\n   * the index key stays untouched.\n   * @param embeddings are the coordinates, has form [{x->val,y->val, index->val},...]\n   * @returns an array of the coordinates of the form [[x, y, index], ...]\n   */\n  scaleEmbeddings(embeddings: Coordinate[]) {\n    let xs = embeddings.map(e => Math.abs(e.x))\n    let ys = embeddings.map(e => Math.abs(e.y))\n    let max_x = _.max(xs) || 0\n    let max_y = _.max(ys) || 0\n    let max = Math.max(max_x, max_y)\n    let scale = d3\n      .scaleLinear()\n      .domain([-max, max])\n      .range([0, 100])\n    let scaled_embeddings = embeddings.map(e => {\n      const coordinate_scaled: Coordinate = {\n        'x': scale(e.x), 'y': scale(e.y), 'index': e.index\n      }\n      return coordinate_scaled\n    }\n    )\n    return scaled_embeddings\n  }\n\n  /**\n   * picks n random elements from arr without duplicates.\n   * \n   * if n is longer than 4/5th of arr's length, random indices of the lenght of the whole\n   * list @param arr is  returned as a random picks would take too many tries to find new indices.\n   * \n   * modified from\n   * https://stackoverflow.com/questions/19269545/how-to-get-a-number-of-random-elements-from-an-array\n   * \n   * @param {*} arr the original giving the shape\n   * @param {*} n how many to pick from\n   */\n  getRandomIndices(arr: any[], n: number) {\n    const indices_arr = Array.from(Array(arr.length).keys()) // why so difficult, js?\n\n    if (n > indices_arr.length * 3 / 5) {\n      return indices_arr\n    }\n\n    var result = new Array(n),\n      len = indices_arr.length,\n      taken = new Array(len);\n    if (n > len)\n      throw new RangeError(\"getRandom: more elements taken than available\");\n    while (n--) {\n      var x = Math.floor(Math.random() * len);\n      result[n] = indices_arr[x in taken ? taken[x] : x];\n      taken[x] = --len in taken ? taken[len] : len;\n    }\n    return result;\n  }\n\n  /**\n   * how many coordinates to pcik form all clusters to show coordinates\n   * @param howMany how many to numbers to pick from all clusters to show\n   */\n  async loadCoordinates(howMany: number) {\n    var all_coordinates_full: NumNeighbors = {\n      '2': { '0.1': null, '0.2': null, '0.5': null, '0.9': null } as MinDist,\n      '5': { '0.1': null, '0.2': null, '0.5': null, '0.9': null } as MinDist,\n      '10': { '0.1': null, '0.2': null, '0.5': null, '0.9': null } as MinDist,\n      '50': { '0.1': null, '0.2': null, '0.5': null, '0.9': null } as MinDist,\n    }\n\n    // creates a combination of all above, i.e. [['2', '0.1'], ['2', '0.2'], ...]\n    const allParamsPairs = Object.keys(all_coordinates_full).flatMap(\n      numNeigbor => Object.keys(all_coordinates_full['2'])\n        .map(mindistEl => [numNeigbor, mindistEl])\n    )\n\n    const allPromisesParamPairs: Promise<boolean>[] = allParamsPairs.map(paramaterPair => {\n      const num_neighbors = paramaterPair[0]\n      const min_dist = paramaterPair[1]\n      return fetch(`${process.env.PUBLIC_URL}/coordinates/coordinates_supervised.${num_neighbors}.${min_dist}.json`)\n        .then((fetched: Response) => fetched.json())\n        .then((coordinates: Coordinate[]) => {\n          const scaled_coordinates: Coordinate[] = this.scaleEmbeddings(coordinates)\n          all_coordinates_full[num_neighbors][min_dist] = scaled_coordinates\n          return true\n        })\n    })\n\n    await Promise.all(allPromisesParamPairs)\n\n    return this.setState({\n      allCoordinatesFull: all_coordinates_full,\n    }, this.calc_quality) // calc_quality doesnt do anything on first run\n  }\n\n\n  async reloadCoordinatesWithSize(newSize: number, callback?: () => void) {\n    // if above 80 %, just take all points\n    const size = newSize > 4 / 5 * (this.state.data?.length || 0) ? (this.state.data?.length || 0) : newSize\n\n    const numNeighbors = this.state.coordinatesParameters.numNeighborsParameter\n    const minDist = this.state.coordinatesParameters.minDistParameter\n\n    const randIndices = this.getRandomIndices(this.state.labels || [], size)\n    const coordinates = randIndices.map(i => this.state.allCoordinatesFull![numNeighbors][minDist]![i])\n\n    this.setState({\n      coordinates_to_show: size,\n      allCoordinates: coordinates\n    })\n  }\n\n\n  async loadDataAndSearchIndex() {\n    const fetched = await fetch(`${process.env.PUBLIC_URL}/data.json`)\n    let data: DataPoint[] = JSON.parse(await fetched.text())\n    data.forEach((el, i) => {\n      el.i = i\n    })\n    const search_index = lunr(function () {\n      this.field('comment')\n      this.field('author')\n      this.field('published')\n\n      for (let i = 0; i < data.length; i++) {\n        this.add({\n          'comment': data[i].cleaned,\n          'author': data[i].authorName,\n          'published': data[i].publishedAt,\n          'id': `${i}`,\n        })\n      }\n    })\n    this.setState({\n      data: data,\n      searchIndex: search_index\n    })\n  }\n\n  async loadLabels() {\n    const fetched = await fetch(`${process.env.PUBLIC_URL}/labels.json`)\n    let labels: Label[] = JSON.parse(await fetched.text())\n    labels = labels.map(el => {\n      return {\n        label_kmedoids: `cluster ${el.label_kmedoids}`\n      }\n    })\n\n    this.setState({\n      labels: labels,\n    })\n  }\n\n  /** normalizes cluster quality so that values are in the range [0,1] */\n  _normalize_clusters(clusters: Cluster) {\n    let maxQuality = 0\n    for (let label in clusters) {\n      maxQuality = clusters[label].quality > maxQuality ? clusters[label].quality : maxQuality\n    }\n    let scale = d3.scaleLinear().domain([0, maxQuality]).range([0, 1])\n    for (let label in clusters) {\n      clusters[label].quality = scale(clusters[label].quality)\n    }\n  }\n\n  /** sets the quality for each cluster.\n   * currently named as density\n   */\n  calc_quality() {\n    // using average of squared euclidean distances\n    const clusters = { ...this.state.clusters }\n    for (let label in clusters) {\n      if (!clusters[label].medoid) return // doesnt happen\n      const coordinates = this._getAllSelectedCoordinates()\n      let medoid_pos = coordinates[clusters[label].medoid!]\n\n      let distances = coordinates.map(\n        (coord) => {\n          if (this.state.labels?.[coord.index].label_kmedoids != label) return\n          // is of same cluster:\n          let sqrd_eucl_dist = Math.sqrt(Math.pow(coord.x - medoid_pos.x, 2) + Math.pow(coord.y - medoid_pos.y, 2))\n          return sqrd_eucl_dist\n        }\n      )\n\n      clusters[label].quality = _.mean(distances)\n    }\n\n    this._normalize_clusters(clusters)\n\n    this.setState({\n      clusters: clusters\n    })\n  }\n\n  /** loads cluster representatives from disk and creates clusters state */\n  async loadClusters() {\n    const fetchedReprs = await fetch(`${process.env.PUBLIC_URL}/cluster-representatives.json`)\n    const representatives: { [label: string]: number[] } = JSON.parse(await fetchedReprs.text())\n\n    const fetchedMedoids = await fetch(`${process.env.PUBLIC_URL}/medoids.json`)\n    const medoids: { medoids_indices: number }[] = JSON.parse(await fetchedMedoids.text())\n\n    let clusters: Cluster = {}\n\n    for (let orig_label in representatives) {\n      const changed_label = `cluster ${orig_label}`\n      clusters[changed_label] = {\n        medoid: medoids[parseInt(orig_label)].medoids_indices,\n        representatives: representatives[parseInt(orig_label)],\n        size: 0,\n        quality: 0\n      }\n    }\n\n    for (let label of this.state.labels!) {\n      clusters[label.label_kmedoids].size += 1\n    }\n\n    this.setState({\n      clusters: clusters\n    }, () => this.calc_quality())\n  }\n\n\n  async componentDidMount() {\n    await Promise.all([\n      this.loadCoordinates(this.state.coordinates_to_show), // embeddings\n      this.loadDataAndSearchIndex(),\n      this.loadLabels(),\n    ])\n    await this.setSelectedCoordinates(this.state.coordinatesParameters.numNeighborsParameter, this.state.coordinatesParameters.minDistParameter)\n    await this.loadClusters()\n  }\n\n  render() {\n    const props: PropsFromData = {\n      ...this.state,\n      reloadCoordinatesWithSize: this.reloadCoordinatesWithSize,\n      setSelectedCoordinates: this.setSelectedCoordinates,\n      setClustersToShow: this.setClustersToShow,\n      renameLabels: this.renameLabels,\n      pushToDataChanged: this.pushToDataChanged,\n      setHoveredCommentCoordinate: this.setHoveredCommentCoordinate,\n      setChangedClusterName: this.setChangedClusterName,\n    }\n    return this.state.allCoordinates && this.state.data && this.state.labels && this.state.clusters ? (\n      <Layout {...props} />\n    ) : (\n        <div style={{ padding: '1rem' }}>Loading data...</div>\n      )\n  }\n}","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Layout.tsx",["174","175"],"import * as _ from 'lodash'\nimport React, { Component } from 'react'\nimport SplitPane from 'react-split-pane'\nimport { PropsFromData } from './Data'\nimport Projection, { PropsForProjection } from './ProjectionElements/Projection'\nimport ProjectionParameters from './ProjectionElements/ProjectionParameters'\nimport Sidebar, { PropsForSidebar } from './Sidebar'\nimport Sidebar2 from './Sidebar2'\n\nconst minSizePanel = 350\n\n\nexport type LayoutState = {\n  ww: number | null,\n  wh: number | null,\n  sidebar_height: number | null,\n  /** is the index of the comment clicked on by the user in the projection, or null if nothing selected */\n  selected_datum: number | null,\n  searchInput: string,\n  // for faster lookup, as object of form {'id':position, ...} with position being rank in results\n  searchResultIndices: object,\n  /** is the cluster of which user wants a detail view */\n  selectedCluster: string | null,\n  sidebar_width: number | null,\n  /** the width in px of the svg element */\n  svg_width: number | null,\n  /** at every drag of the user, we need to redraw the svg element. This is done with the key prop */\n  svgKey: string\n}\n\nclass Layout extends Component<PropsFromData, LayoutState> {\n  sidebar_ctx: any | null\n  sidebar_mount: HTMLDivElement | null = null\n\n  constructor(props: PropsFromData) {\n    super(props)\n    this.state = {\n      ww: null,\n      wh: null,\n      sidebar_height: null,\n      sidebar_width: null,\n      svg_width: null,\n      selected_datum: null,\n      searchInput: \"\",\n      searchResultIndices: {},\n      selectedCluster: null,\n      svgKey: \"1\",\n    }\n    this.sidebar_ctx = null\n    this.setSize = _.debounce(this.setSize.bind(this), 200)\n    this.setSelectedDatum = this.setSelectedDatum.bind(this)\n    this.updateSearchResultIndices = this.updateSearchResultIndices.bind(this)\n    this.selectCluster = this.selectCluster.bind(this)\n  }\n\n  selectCluster(newLabel: string) {\n    this.setState({\n      selectedCluster: newLabel\n    })\n    this.props.setChangedClusterName({\n      original: newLabel,\n      changed: newLabel\n    })\n  }\n\n  setSize() {\n    let sidebar_height = this.sidebar_mount?.offsetHeight || 0\n    let sidebar_width = _.max([window.innerWidth / 4 || 350, 350]) || 350\n    let svg_width = _.min([window.innerWidth - (2 * minSizePanel), 0.5 * window.innerWidth]) || window.innerWidth - (2 * minSizePanel)\n    this.setState({\n      sidebar_height: sidebar_height,\n      sidebar_width: sidebar_width,\n      svg_width: svg_width,\n      ww: window.innerWidth,\n      wh: window.innerHeight,\n    })\n  }\n\n  componentWillMount() {\n    this.setSize()\n  }\n\n  componentDidMount() {\n    window.addEventListener('resize', this.setSize)\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.setSize)\n  }\n\n  haveEmbeddingsChanged(prevProps: PropsFromData) {\n    return prevProps.embeddings !== this.props.embeddings || prevProps.embeddings.length !== this.props.embeddings.length\n  }\n\n  /**\n   * sets the selected datum which causes it to show in the sidebar \n   * @param {int} i is the index of the selected datum\n   */\n  setSelectedDatum(i: number | null) {\n    if (!this.props.labels) return\n    this.setState({\n      selected_datum: i,\n      selectedCluster: (i) ? this.props.labels[i].label_kmedoids : null\n    })\n  }\n\n\n  updateSearchResultIndices(searchTerm: string) {\n    if (searchTerm.length < 1) return\n    let searchResults = this.props.searchIndex?.search(searchTerm)\n    let searchResultsCleaned: any = searchResults?.map((result: lunr.Index.Result, i) => [result.ref, i])\n    this.setState({\n      searchInput: searchTerm,\n      searchResultIndices: Object.fromEntries(searchResultsCleaned),\n      selected_datum: null, // empty sidebar\n    })\n  }\n\n  render() {\n    let sidebar_ctx = this.sidebar_ctx\n    let line_height = 1.5\n    let sidebar_style: any = {\n      height: this.state.wh,\n      overflow: 'auto', background: '#222',\n      display: 'flex', flexDirection: 'column',\n    }\n    let main_style: any = {\n      position: 'inline-block', height: this.state.wh,\n      background: '#111', overflow: 'hidden',\n    }\n\n    let sidebar_orientation\n    let font_size = 16\n    sidebar_orientation = 'vertical'\n\n    const propsForSidebar: PropsForSidebar = {\n      ...this.props,\n      ...this.state,\n      setSelectedDatum: this.setSelectedDatum,\n      selectCluster: this.selectCluster,\n      sidebar_orientation: sidebar_orientation,\n    }\n\n    // show all coordinates to show in array of array which is more performant\n    const allCoordinatesAsArrayFilt = this.props.allCoordinates!\n      .filter(d => this.props.clustersToShow.includes(this.props.labels?.[d.index].label_kmedoids || \"\")) // only comments of clusters set visible\n      .map(d => [d.x, d.y, d.index])\n\n    const propsForProjection: PropsForProjection = {\n      ...this.props,\n      width: this.state.svg_width || 0,\n      height: main_style.height,\n      sidebar_ctx: sidebar_ctx,\n      selectedCluster: this.state.selectedCluster,\n      setSelectedDatum: this.setSelectedDatum,\n      selected_datum: this.state.selected_datum,\n      searchResultIndices: this.state.searchResultIndices,\n      selectCluster: this.selectCluster,\n      allCoordinatesAsArray: allCoordinatesAsArrayFilt\n    }\n\n    /* code for search bar, add above splitpane\n    <div style={general_style}>\n        <div style={{ position: 'absolute', zIndex: 10, left: '50%', marginLeft: '-10vw', right: '50%', top: '4vh', width: '30vw' }}>\n          <SearchBar\n            value={this.state.searchInput}\n            onChange={this.updateSearchResultIndices}\n          />\n        </div>\n        splitpane\n    </div>\n    */\n\n    return this.state.ww! !== null ? (\n      <SplitPane\n        split=\"vertical\"\n        minSize={minSizePanel}\n        maxSize={700}\n        defaultSize={this.state.sidebar_width || minSizePanel}\n        onChange={(newWidth) => {\n          this.setState({\n            sidebar_width: newWidth + 8,\n            svgKey: `${parseInt(this.state.svgKey) + 1}` // forces redrawing of component\n          })\n        }\n        }\n      >\n        <div\n          style={sidebar_style}\n          ref={sidebar_mount => {\n            this.sidebar_mount = sidebar_mount\n          }}\n        >\n          <Sidebar {...propsForSidebar} />\n        </div>\n        <SplitPane\n          split=\"vertical\"\n          minSize={400}\n          defaultSize={this.state.svg_width || 400}\n          maxSize={this.state.ww - (2 * minSizePanel)}\n          onChange={(newWidth) => {\n            this.setState({\n              svg_width: newWidth,\n              svgKey: `${parseInt(this.state.svgKey) + 1}` // forces redrawing of component\n            })\n          }\n          }\n        >\n          <div style={main_style}>\n            <ProjectionParameters {...propsForProjection} />\n            <Projection key={this.state.svgKey} {...propsForProjection} />\n          </div>\n          <div style={sidebar_style}>\n            <Sidebar2 {...propsForSidebar} />\n          </div>\n        </SplitPane>\n      </SplitPane>\n    ) : (\n        <div style={{ padding: '1rem' }}>Loading layout...</div>\n      )\n  }\n}\n\nexport default Layout\n","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Sidebar.tsx",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterOverview/ClusterOverview.tsx",["176","177","178","179"],"import React, { SetStateAction, useState } from 'react';\nimport ClusterSnippet from './ClusterSnippet'\nimport ClusterTable from './ClusterTable';\nimport { PropsForSidebar } from '../../Sidebar';\nimport ClusterMerger from '../ClusterMerger';\nimport { DataPoint } from '../../Data';\nimport { Accordion, AccordionDetails, AccordionSummary, Card, makeStyles, Tooltip, Typography } from '@material-ui/core';\nimport { ExpandMore } from '@material-ui/icons';\nimport CardContent from '@material-ui/core/CardContent';\n\n\nexport type PropsForClusterOverview = PropsForSidebar\n\nconst useStyles = makeStyles(theme => ({\n    padding: {\n        padding: theme.spacing(2),\n    },\n    marginCard: {\n        marginLeft: theme.spacing(2),\n        marginRight: theme.spacing(2),\n        marginBottom: theme.spacing(3)\n    },\n    rightMargin: {\n        marginRight: theme.spacing(2)\n    },\n    root: { // accordion\n        margin: theme.spacing(2)\n    },\n    heading: {\n        fontSize: theme.typography.pxToRem(15),\n        flexBasis: '33.33%',\n        flexShrink: 0,\n    },\n    secondaryHeading: {\n        fontSize: theme.typography.pxToRem(15),\n        color: theme.palette.text.secondary,\n    },\n    tootltip: {\n        fontSize: '0.8em',\n    }\n}))\n\n/**\n * \n * @param comments is the subset of the data which has label @param label\n * @param label is the label of said comments\n */\nexport default function ClusterOverview(props: PropsForClusterOverview) {\n    const classes = useStyles()\n    const expandSentence = \"Click to expand\"\n    const minimizeSentence = \"Click to minimize\"\n    const [mergeExplainer, setMergeExplainer] = useState<string>(expandSentence)\n\n    const buildHeadlineAndInfo = (headline: string, caption: string | null) => (\n        <div className={classes.padding}>\n            <Typography variant='h5'>{headline}</Typography>\n            {caption &&\n                <Typography variant=\"body2\">{caption}</Typography>\n            }\n        </div>\n    )\n\n    const legend = (\n        <div className={classes.padding}>\n            <Typography variant='body2' style={{ backgroundColor: 'rgba(255, 255, 255, 0.15)', padding: '8px' }}>Checked cluster comments are white in the visualization</Typography>\n            <Typography variant='body2' style={{ backgroundColor: 'rgba(245, 124, 0, 0.7)', padding: '8px' }}>The selected cluster's comments are orange in the visualization</Typography>\n        </div>)\n\n    const metaInfo = (\n        <Card\n            variant=\"outlined\"\n            className={classes.marginCard}\n        >\n            <CardContent>\n                <Typography variant=\"body1\" gutterBottom>\n                    {`Comments in total: ${props.labels?.length || \"undefined\"}`}\n                </Typography>\n                <Typography variant=\"body1\">\n                    {`Number of clusters: ${Object.keys(props.clusters).length || \"undefined\"}`}\n                </Typography>\n            </CardContent>\n        </Card>\n    )\n\n    const whatAmISeeingTooltip = (\n        <Tooltip\n        title=\"This is a list of all clusters. Grey entries (checked checkbox) are currently visible in the visualization. The cluster seen in the details pane (right) is highlighted orange.\"\n        placement=\"bottom-end\"\n        classes={{tooltip: classes.tootltip}}\n        >\n            <Typography\n                align=\"right\"\n                variant=\"subtitle2\"\n                className={classes.rightMargin}\n            >\n                What am I seeing here?\n            </Typography>\n        </Tooltip>\n    )\n\n    return (\n        <>\n            <Accordion className={classes.root} onChange={() => {\n                if (mergeExplainer === expandSentence) {\n                    setMergeExplainer(minimizeSentence)\n                } else {\n                    setMergeExplainer(expandSentence)\n                }\n            }}>\n                <AccordionSummary\n                    expandIcon={<ExpandMore />}\n                    aria-controls=\"cluster merger\"\n                    id=\"cluster merger\"\n                >\n                    <Typography className={classes.heading}>Merge Clusters</Typography>\n                    <Typography className={classes.secondaryHeading}>{mergeExplainer}</Typography>\n                </AccordionSummary>\n                <AccordionDetails style={{ display: 'block' }}>\n                    <ClusterMerger {...props} />\n                </AccordionDetails>\n            </Accordion>\n            {buildHeadlineAndInfo('Clusters Overview', \"Browse all clusters.\")}\n            {metaInfo}\n            {whatAmISeeingTooltip}\n            <ClusterTable {...props} />\n        </>\n    )\n}","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterOverview/ClusterTable.tsx",["180","181","182"],"import Checkbox from '@material-ui/core/Checkbox';\nimport Paper from '@material-ui/core/Paper';\nimport { makeStyles } from '@material-ui/core/styles';\nimport Table from '@material-ui/core/Table';\nimport TableBody from '@material-ui/core/TableBody';\nimport TableCell from '@material-ui/core/TableCell';\nimport TableContainer from '@material-ui/core/TableContainer';\nimport TableHead from '@material-ui/core/TableHead';\nimport TablePagination from '@material-ui/core/TablePagination';\nimport TableRow from '@material-ui/core/TableRow';\nimport TableSortLabel from '@material-ui/core/TableSortLabel';\nimport Typography from '@material-ui/core/Typography';\nimport PropTypes from 'prop-types';\nimport React, { useEffect, useState } from 'react';\nimport { Cluster } from '../../Data';\nimport { PropsForSidebar } from '../../Sidebar';\nimport InfoOutlinedIcon from '@material-ui/icons/InfoOutlined';\nimport { Tooltip } from '@material-ui/core';\n\ntype Row = {\n    label: string,\n    size: number,\n    metric: string,\n    sizePrct: string\n}\n\ntype OrderBy = 'label' | 'size' | 'metric'\n\ntype ClusterInfoDict = {\n    [label: string]: {\n        'size': number,\n        'metric': number,\n    }\n}\n\nvar labelsAndData = {}\nvar rows: Row[] = []\n\nfunction descendingComparator(a: Row, b: Row, orderBy: OrderBy) {\n    if (b[orderBy] < a[orderBy]) {\n        return -1;\n    }\n    if (b[orderBy] > a[orderBy]) {\n        return 1;\n    }\n    return 0;\n}\n\nfunction getComparator(order: string, orderBy: OrderBy) {\n    return order === 'desc'\n        ? (a: Row, b: Row) => descendingComparator(a, b, orderBy)\n        : (a: Row, b: Row) => -descendingComparator(a, b, orderBy);\n}\n\nfunction stableSort(array: Row[], comparator: (a: Row, b: Row) => number) {\n    const stabilizedThis = array.map((el, index) => [el, index]);\n    stabilizedThis.sort((a: any, b: any) => {\n        const order = comparator(a[0], b[0]);\n        if (order !== 0) return order;\n        return a[1] - b[1];\n    });\n    return stabilizedThis.map((el) => el[0] as Row);\n}\n\nconst useTooltipStyles = makeStyles(theme => ({\n    tootltip: {\n        fontSize: '0.8em',\n    }\n}))\n\nfunction EnhancedTableHead(props: any) {\n    const { classes, onSelectAllClick, order, orderBy, numSelected, rowCount, onRequestSort } = props;\n    const createSortHandler = (property: string) => (event: any) => {\n        onRequestSort(event, property);\n    };\n    const classesTooltip = useTooltipStyles()\n\n    const headCells = [\n        { id: 'label', numeric: false, disablePadding: true, label: 'Cluster Name' },\n        { id: 'size', numeric: true, disablePadding: false, label: 'Size (in\\u00A0%)'},\n        { id: 'metric', numeric: true, disablePadding: false, label: 'Density', sublabel: 'Density describes how close comments of the same cluster lie together, with 0 being the densest cluster and 1 being the farthest spread out cluster.' },\n    ];\n\n    return (\n        <TableHead>\n            <TableRow>\n                <TableCell padding=\"checkbox\">\n                    <Checkbox\n                        indeterminate={numSelected > 0 && numSelected < rowCount}\n                        checked={rowCount > 0 && numSelected === rowCount}\n                        onChange={onSelectAllClick}\n                        inputProps={{ 'aria-label': 'show all clusters' }}\n                    />\n                </TableCell>\n                {headCells.map((headCell) => (\n                    <TableCell\n                        key={headCell.id}\n                        align={headCell.numeric ? 'right' : 'left'}\n                        padding={headCell.disablePadding ? 'none' : 'default'}\n                        sortDirection={orderBy === headCell.id ? order : false}\n                    >\n                        <TableSortLabel\n                            active={orderBy === headCell.id}\n                            direction={orderBy === headCell.id ? order : 'asc'}\n                            onClick={createSortHandler(headCell.id)}\n                        >\n                            {headCell.sublabel && <Tooltip\n                                title={headCell.sublabel}\n                                placement=\"bottom-end\"\n                                classes={{tooltip: classesTooltip.tootltip}}\n                            >\n                                <InfoOutlinedIcon style={{marginLeft: '8px', fontSize: '1em'}}/>\n                            </Tooltip>}\n                            <Typography style={{ fontWeight: 600 }}>{headCell.label}</Typography>\n                            {orderBy === headCell.id ? (\n                                <span className={classes.visuallyHidden}>\n                                    {order === 'desc' ? 'sorted descending' : 'sorted ascending'}\n                                </span>\n                            ) : null}\n                        </TableSortLabel>\n                    </TableCell>\n                ))}\n            </TableRow>\n        </TableHead>\n    );\n}\n\nEnhancedTableHead.propTypes = {\n    classes: PropTypes.object.isRequired,\n    numSelected: PropTypes.number.isRequired,\n    onRequestSort: PropTypes.func.isRequired,\n    onSelectAllClick: PropTypes.func.isRequired,\n    order: PropTypes.oneOf(['asc', 'desc']).isRequired,\n    orderBy: PropTypes.string.isRequired,\n    rowCount: PropTypes.number.isRequired,\n};\n\nconst useStyles = makeStyles((theme) => ({\n    paper: {\n        color: 'white',\n        backgroundColor: 'unset',\n        width: '100%',\n        marginBottom: theme.spacing(2),\n    },\n    table: {\n        color: 'white',\n    },\n    visuallyHidden: {\n        border: 0,\n        clip: 'rect(0 0 0 0)',\n        height: 1,\n        margin: -1,\n        overflow: 'hidden',\n        padding: 0,\n        position: 'absolute',\n        top: 20,\n        width: 1,\n    },\n}));\n\nconst useTablePaginationStyles = makeStyles((theme) => ({\n    spacer: {\n        flex: '1'\n    },\n    actions: {\n        marginLeft: '0',\n        marginRight: '0'\n    },\n    input: {\n        flex: '1 3 100%',\n        marginLeft: '0',\n        marginRight: '0'\n    },\n    caption: {\n        flex: '1 1 100%'\n    },\n\n}))\n\n\nfunction clustersToRows(clusters: Cluster, sumComments: number) {\n    let rows: Row[] = []\n    for (let label in clusters) {\n        const sizePrct = (clusters[label].size * 100 / sumComments).toFixed(1)\n        rows.push({ 'label': label, 'size': clusters[label].size, 'metric': clusters[label].quality.toFixed(2), 'sizePrct': sizePrct })\n    }\n    return rows\n}\n\ntype PropsClusterTable = PropsForSidebar\nexport default function ClusterTable({\n    labels,\n    data,\n    dataChanged,\n    clustersToShow,\n    setClustersToShow,\n    selectCluster,\n    setSelectedDatum,\n    selectedCluster,\n    ...other }: PropsClusterTable) {\n\n    const classes = useStyles();\n    const classesTablePagination = useTablePaginationStyles()\n    const [order, setOrder] = useState('desc');\n    const [orderBy, setOrderBy] = useState('size' as OrderBy);\n    const [page, setPage] = useState(0);\n    const [rowsPerPage, setRowsPerPage] = useState(10);\n\n    rows = clustersToRows(other.clusters, labels?.length || 0)\n\n    const handleRequestSort = (event: any, property: OrderBy) => {\n        const isAsc = orderBy === property && order === 'asc';\n        setOrder(isAsc ? 'desc' : 'asc');\n        setOrderBy(property);\n    };\n\n    const handleSelectAllClick = (event: any) => {\n        if (event.target.checked) {\n            const newSelecteds = rows.map((n) => n.label);\n            setClustersToShow(newSelecteds);\n            return;\n        }\n        setClustersToShow([]);\n    };\n\n    const handleCheckboxClick = (event: any, name: string) => {\n        const selectedIndex = clustersToShow.indexOf(name);\n        let newSelected: string[] = [];\n\n        if (selectedIndex === -1) { // wasn't clicked before\n            newSelected = newSelected.concat(clustersToShow, name);\n        } else if (selectedIndex === 0) { // \n            newSelected = newSelected.concat(clustersToShow.slice(1));\n        } else if (selectedIndex === clustersToShow.length - 1) { // is last one\n            newSelected = newSelected.concat(clustersToShow.slice(0, -1));\n        } else if (selectedIndex > 0) { // unselected\n            newSelected = newSelected.concat(\n                clustersToShow.slice(0, selectedIndex),\n                clustersToShow.slice(selectedIndex + 1),\n            );\n        }\n\n        setClustersToShow(newSelected);\n    }\n\n    const handleRowClick = (event: any, name: string) => {\n        if (event.target.nodeName === \"INPUT\") return // skip if over checkbox, which is handled by handleCheckboxClick\n        if (selectedCluster !== name) { // change detail view\n            setSelectedDatum(null)\n            selectCluster(name)\n        }\n        // click checkbox if not clicked yet\n        const selectedIndex = clustersToShow.indexOf(name);\n        let newSelected: string[] = [];\n\n        if (selectedIndex === -1) { // wasn't clicked before\n            newSelected = newSelected.concat(clustersToShow, name);\n            setClustersToShow(newSelected);\n        }\n    };\n\n    const handleChangePage = (event: any, newPage: number) => {\n        setPage(newPage);\n    };\n\n    const handleChangeRowsPerPage = (event: any) => {\n        setRowsPerPage(parseInt(event.target.value, 10));\n        setPage(0);\n    };\n\n    const isSelected = (name: string) => clustersToShow.indexOf(name) !== -1;\n\n    const emptyRows = rowsPerPage - Math.min(rowsPerPage, rows.length - page * rowsPerPage);\n\n    const rowsSorted = stableSort(rows, getComparator(order, orderBy))\n\n    useEffect(() => {\n        rows = clustersToRows(other.clusters, data?.length || 0)\n    }, [other.clusters, data]) // if clusters change, update rows\n\n    return (\n        <div>\n            <Paper className={classes.paper}>\n                <TableContainer>\n                    <Table\n                        style={{ width: '100%', minWidth: 'auto' }}\n                        className={classes.table}\n                        aria-labelledby=\"tableTitle\"\n                        size='medium'\n                        aria-label=\"cluster table\"\n                    >\n                        <EnhancedTableHead\n                            classes={classes}\n                            numSelected={clustersToShow.length}\n                            order={order}\n                            orderBy={orderBy}\n                            onSelectAllClick={handleSelectAllClick}\n                            onRequestSort={handleRequestSort}\n                            rowCount={rows.length}\n                        />\n                        <TableBody>\n                            {rowsSorted\n                                .slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage)\n                                .map((row: Row, index: number) => {\n                                    const isItemSelected = isSelected(row.label);\n                                    const labelId = `enhanced-table-checkbox-${index}`;\n                                    return (\n                                        <TableRow\n                                            hover\n                                            onClick={(event: any) => handleRowClick(event, row.label)}\n                                            role=\"checkbox\"\n                                            aria-checked={isItemSelected}\n                                            tabIndex={-1}\n                                            key={row.label}\n                                            selected={isItemSelected}\n                                            style={selectedCluster === row.label ? { backgroundColor: 'rgba(245, 124, 0, 0.7)' } : {}}\n                                        >\n                                            <TableCell padding=\"checkbox\">\n                                                <Checkbox\n                                                    color='secondary'\n                                                    checked={isItemSelected}\n                                                    inputProps={{ 'aria-labelledby': labelId }}\n                                                    onClick={(event) => handleCheckboxClick(event, row.label)}\n                                                />\n                                            </TableCell>\n                                            <TableCell component=\"th\" id={labelId} scope=\"row\" padding=\"none\">\n                                                {selectedCluster === row.label ? other.changedClusterName?.changed : row.label}\n                                            </TableCell>\n                                            <TableCell align=\"right\">{`${row.size} (${row.sizePrct})`}</TableCell>\n                                            <TableCell align=\"right\">{row.metric}</TableCell>\n                                        </TableRow>\n                                    );\n                                })}\n                        </TableBody>\n                    </Table>\n                </TableContainer>\n                <TablePagination\n                    classes={classesTablePagination}\n                    rowsPerPageOptions={[10, 20, 45]}\n                    component=\"div\"\n                    count={rows.length}\n                    rowsPerPage={rowsPerPage}\n                    page={page}\n                    onChangePage={handleChangePage}\n                    onChangeRowsPerPage={handleChangeRowsPerPage}\n                />\n            </Paper>\n        </div>\n    );\n}\n","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/ClusterMenu.tsx",["183","184","185","186","187","188"],"import AppBar from '@material-ui/core/AppBar';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport IconButton from '@material-ui/core/IconButton';\nimport { Save } from '@material-ui/icons';\nimport { createStyles, makeStyles, TextField, Theme, Tooltip } from '@material-ui/core';\nimport { PropsForSidebar } from '../../Sidebar'\nimport React, { useEffect, useState } from 'react';\n\n\nconst useStyles = makeStyles((theme: Theme) => ({\n    root: {\n        flexGrow: 1,\n    },\n    menuButton: {\n        color: 'white',\n        marginLeft: theme.spacing(2),\n    },\n    title: {\n        flexGrow: 1,\n    },\n    colorPrimary: {\n        backgroundColor: 'rgba(245, 124, 0, 0.7)' // orange kinda\n    }\n})\n)\n\ntype PropsClusterMenu = {\n    labelLocal: string,\n    setLabelLocal: (newLabel: string) => void\n} & PropsForSidebar\n\nexport default function ClusterMenu(props: PropsClusterMenu) {\n    const classes = useStyles()\n\n    // onChange={(e: any) => props.setLabelLocal(e.target.value)}\n    return (\n        <AppBar position='relative' color='primary' classes={{ colorPrimary: classes.colorPrimary }} >\n            <Toolbar style={{ marginTop: '8px' }}>\n                <TextField\n                    inputProps={{ style: { fontSize: '1.5em', fontWeight: 600, padding: '8px' } }}\n                    variant=\"outlined\"\n                    label=\"Change Cluster Name\"\n                    value={props.labelLocal}\n                    onChange={(e: any) => props.setLabelLocal(e.target.value)}\n                />\n            </Toolbar>\n        </AppBar>\n    )\n}","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/MetaInfo.tsx",["189","190","191","192"],"import { PropsForSidebar } from '../../Sidebar'\nimport { Cluster, ClusterInfo, DataPoint } from '../../Data'\nimport React from 'react'\nimport TextField from '@material-ui/core/TextField'\nimport NeoMorphCard from './NeoMorphCard'\nimport { makeStyles } from '@material-ui/core/styles'\nimport { Card, CardContent } from '@material-ui/core'\n\n\ntype PropsMetaInfos = {\n    selectedClusterInfo: ClusterInfo\n} & PropsForSidebar\n\nconst useStyles = makeStyles((theme) => ({\n    styleContainer: {\n        display: 'block',\n        marginLeft: theme.spacing(2),\n        marginRight: theme.spacing(2),\n        marginBottom: theme.spacing(2),\n    }\n}))\n\nexport default function MetaInfo(props: PropsMetaInfos) {\n    const classes = useStyles()\n    const { selectedClusterInfo } = props\n\n    const prct = ((selectedClusterInfo?.size || 0) * 100 / (props.data?.length || 1)).toFixed(2)\n    return (\n        <Card className={classes.styleContainer}>\n            <CardContent>\n                <p><b>Size:</b> {selectedClusterInfo?.size || 0} of {props.data?.length} comments in total</p>\n                <p><b>Size (in %):</b> {prct} %</p>\n                <p><b>Density</b> (lower is better): {selectedClusterInfo?.quality?.toFixed(3) || 0}</p>\n            </CardContent>\n        </Card>\n    )\n}",["193","194"],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/NeoMorphCard.tsx",["195","196","197"],"import { PropsForSidebar } from '../../Sidebar'\nimport { createUseStyles } from 'react-jss'\nimport { DataPoint } from '../../Data'\nimport React from 'react'\nimport TextField from '@material-ui/core/TextField'\n\nconst useStyles = createUseStyles(\n    {\n        card: {\n            display: 'block',\n            margin: '32px 24px',\n            padding: '4px 16px',\n            position: 'relative',\n        },\n        neomorphism: {\n            borderRadius: '15px',\n            background: 'linear-gradient(145deg, #373737, #2e2e2e)',\n            boxShadow: '5px 5px 12px #181818, -5px -5px 12px #4e4e4e'\n        },\n    })\n\ntype NeoMorphProps = {\n    children: React.ReactNode\n}\n\nexport default function NeoMorphCard(props: NeoMorphProps) {\n    const classes = useStyles()\n\n    return (\n        <div className={`${classes.neomorphism} ${classes.card}`}>\n            {props.children}\n        </div>\n    )\n}",["198","199"],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterMerger.tsx",["200","201"],"import { Button, makeStyles, TextField } from \"@material-ui/core\";\nimport Autocomplete from '@material-ui/lab/Autocomplete';\nimport React, { useState } from \"react\";\nimport { PropsForSidebar } from \"../Sidebar\";\n\nconst useStyles = makeStyles((theme) => ({\n    horizontalContainer: {\n        paddingRight: theme.spacing(3),\n        paddingLeft: theme.spacing(3),\n        paddingTop: '1em',\n        paddingBottom: '1em',\n        width: 'auto',\n        height: 'auto'\n    },\n    rightAlign: {\n        display: 'block',\n        marginLeft: 'auto',\n        marginRight: '0'\n    },\n    gridContainer: {\n        display: 'grid',\n        gridTemplateColumns: '9fr 1fr',\n        gridRowGap: theme.spacing(1)\n    }\n}));\n\nexport default function ClusterMerger(props: PropsForSidebar) {\n    const classes = useStyles()\n    const [newClusterName, setName] = useState('New Cluster Name')\n    const [firstLabel, setFirstLabel] = useState<string | null>(null)\n    const [secondLabel, setSecondLabel] = useState<string | null>(null)\n\n    const allClusters = Array.from(new Set(props.labels?.map(label => label.label_kmedoids)))\n\n    const merge = () => {\n        if (!firstLabel || !secondLabel) return\n        props.renameLabels([firstLabel, secondLabel], newClusterName)\n        props.setSelectedDatum(null)\n        props.selectCluster(newClusterName)\n        if (!props.clustersToShow.includes(newClusterName)) {\n            props.setClustersToShow([...props.clustersToShow, newClusterName])\n        }\n        setFirstLabel(null)\n        setSecondLabel(null)\n    }\n\n    const groupByVisibleClusters = (option: string) =>\n        (props.clustersToShow?.includes(option))\n            ? \"Visible Clusters\"\n            : \"Other Clusters\"\n\n    /** comparator to sort array by its visibility in the projection */\n    const compareByVisibility = (a: string, b: string) => {\n        const aGroup = groupByVisibleClusters(a)\n        const bGroup = groupByVisibleClusters(b)\n        if (aGroup < bGroup) return 1\n        else if (aGroup === bGroup) return 0\n        else return -1 //(aGroup > bGroup)\n    }\n\n    return (\n        <>\n            <div className={classes.gridContainer}>\n                <Autocomplete\n                    options={allClusters.filter(cluster => cluster != secondLabel).sort(compareByVisibility)}\n                    groupBy={groupByVisibleClusters}\n                    renderInput={(params: any) => <TextField {...params} label=\"First\" variant=\"outlined\" />}\n                    onChange={(e, value) => setFirstLabel(value!)}\n                    value={firstLabel}\n                />\n                <p style={{ textAlign: 'center' }}>+</p>\n                <Autocomplete\n                    options={allClusters.filter(cluster => cluster != firstLabel).sort(compareByVisibility)}\n                    groupBy={groupByVisibleClusters}\n                    renderInput={(params: any) => <TextField {...params} label=\"Second\" variant=\"outlined\" />}\n                    onChange={(e, value) => setSecondLabel(value!)}\n                    value={secondLabel}\n                />\n                <p style={{ textAlign: 'center' }}>=</p>\n                <TextField\n                    variant='outlined'\n                    value={newClusterName}\n                    onChange={(e) => setName(e.target.value)}\n                />\n            </div>\n            <div className={classes.horizontalContainer}>\n                <Button\n                    className={classes.rightAlign}\n                    variant=\"contained\"\n                    color=\"primary\"\n                    onClick={merge}\n                    disabled={!(firstLabel && secondLabel)}\n                >Merge</Button>\n            </div>\n        </>\n    )\n}","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/ProjectionElements/Projection.tsx",["202","203","204","205","206","207","208","209","210","211","212","213","214","215"],"import React, { Component } from 'react'\nimport * as d3 from 'd3'\nimport { Coordinate, PropsFromData } from '../Data'\nimport { ZoomBehavior } from 'd3-zoom'\nimport _, { join, stubFalse } from 'lodash'\n\nexport type PropsForProjection = {\n  width: number,\n  height: number,\n  sidebar_ctx: number,\n  selectedCluster: string | null,\n  selectCluster: (newLabel: string) => void,\n  setSelectedDatum: (newDatumIndex: number) => void,\n  selected_datum: number | null,\n  searchResultIndices: object & {\n    [key: string]: any | null\n  },\n  /** this is the same as allCoordinates with only clusters selected to show, but\n   * arranged as array of arrays of form [x, y, index].\n   * This increases the performance substantially\n   * \n   * its actually a number[] but ts was giving errors when unpacking those\n  */\n  allCoordinatesAsArray: any[]\n} & PropsFromData\n\n\nclass Projection extends Component<PropsForProjection, {}> {\n  ref: SVGSVGElement | null = null\n  svg: d3.Selection<SVGSVGElement, any, null, undefined> | null = null\n  group: d3.Selection<SVGGElement, any, null, undefined> | null = null\n  scaleTransform: any = null\n  zoomBehavior: ZoomBehavior<SVGSVGElement, Coordinate> | null = null\n  fillOpacity = 0.8\n  hoverColor = 'rgba(245, 124, 0, 1)' // orange kinda\n\n  constructor(props: PropsForProjection) {\n    super(props)\n    this.state = {}\n  }\n\n\n  /** \n   * draws scatter plot\n   */\n  async drawScatterPlot() {\n    if (!this.ref) return\n\n    const { width, height, setSelectedDatum, allCoordinatesAsArray,\n      clustersToShow, selectCluster, labels } = this.props\n    this.svg = !this.svg ? d3.select(this.ref) : this.svg\n    this.group = !this.group\n      ? this.svg.append('g')\n      : this.group\n\n    const coordsToShow = allCoordinatesAsArray\n\n    const circles = await this.group.selectAll(\"circle\")\n      .data(coordsToShow, ([x, y, index]) => index)\n      .join(\n        enter => enter.append(\"circle\")\n          .attr('id', ([x, y, index]) => index)\n          .attr(\"cx\", ([x, y, index]) => x)\n          .attr(\"cy\", ([x, y, index]) => y)\n          .attr('fill-opacity', 0.0)\n          .call(enter => enter\n            .transition()\n            .duration(500)\n            .delay((d, i) => i / this.props.coordinates_to_show * 200) // Dynamic delay (i.e. each item delays a little longer)\n            .attr('fill-opacity', this.fillOpacity)\n          )\n        ,\n        update => update\n          .call(update => update\n            .transition()\n            .duration(2000)\n            .attr(\"cx\", ([x, y, index]) => x)\n            .attr(\"cy\", ([x, y, index]) => y)\n          ),\n        exit => exit\n          .call(text => text.transition()\n            .duration(500)\n            .delay((d, i) => i / this.props.coordinates_to_show * 200) // Dynamic delay (i.e. each item delays a little longer)\n            .remove()\n            .attr('fill-opacity', 0)\n          )\n      )\n      .attr(\"r\", 0.5)\n      .attr(\"fill\", 'white')\n\n    // this click event causes the react lifecycle method componentDidUpdate\n    // to be called. There, we'll update the colors. (the props in this\n    // function body aren't up to date at that point)\n    circles.on(\"click\", event => {\n      let selected_datum_i = parseInt(event.target.id)\n      setSelectedDatum(selected_datum_i)\n      selectCluster(labels![selected_datum_i].label_kmedoids)\n    })\n\n    // zoom behavior\n    this.zoomBehavior = this.getZoomBehavior(this.group)\n    this.svg.call(this.zoomBehavior)\n\n    // start with scaled up init view if first time, else take previours scale state \n    this.svg.call(this.zoomBehavior.transform, this.scaleTransform || this.getInitScale(width, height))\n\n    if (this.props.selectedCluster) this.updateColorPoints()\n  }\n\n  /** \n   * returns function which applies a transformation after each zoom\n   * event (that is, dragging around + zooming).\n   * \n   * @param selection is the selection of nodes which should be transformed\n   * @returns a zoomBehavior function, to be called on the node on which this behavior\n   * should be bound to.\n   */\n  getZoomBehavior(selection: d3.Selection<any | null, any, any | null, any | null>): ZoomBehavior<any, any> {\n    return d3.zoom().on(\"zoom\", ({ transform }) => {\n      this.scaleTransform = transform\n      selection.attr(\"transform\", transform)\n    })\n  }\n\n  /** \n   * @param {int} width the width of the surrounding svg container\n   * @param {int} height the height of the surrounding svg container\n   * @returns a zoom behavior function with a scale factor that scales\n   * the data to width and height\n   * \n   * NOTE: assumes that the scale defined in {Data.js} is [0,100]\n   */\n  getInitScale(width: number, height: number) {\n    const scaleFactor = Math.min(width / 100, height / 100) // factor to either fill horizontally or vertically\n    return d3.zoomIdentity.scale(scaleFactor)\n  }\n\n  componentDidMount() {\n    this.drawScatterPlot()\n  }\n\n  /**\n   * updates all points so that the clicked point and the points belonging\n   * to its cluster have distinct colors\n   */\n  updateColorPoints() {\n    const { selected_datum, labels, allCoordinatesAsArray, clustersToShow } = this.props\n    if (!this.svg || !labels || !this.group) return\n\n    const coordsToShow = allCoordinatesAsArray\n    if (coordsToShow.length === 0) return this.svg.selectAll('circle').remove()\n\n\n    this.group.selectAll('circle')\n      .data(coordsToShow, ([x, y, index]) => index)\n      .attr('fill', ([x, y, index]) => {\n        if (index == selected_datum) return 'cyan'\n        if (this.props.selectedCluster == labels[index].label_kmedoids) return this.hoverColor // orange kinda\n        return 'white'\n      })\n  }\n\n  highlightSearchResults() {\n    if (!this.svg || !this.group) return\n    const { selected_datum, labels, labelChoice, allCoordinatesAsArray, searchResultIndices, clustersToShow } = this.props\n    const coordsToShow = allCoordinatesAsArray\n    if (coordsToShow.length === 0) return this.group.selectAll('circle').remove()\n\n    this.group.selectAll('circle')\n      .data(coordsToShow, ([x, y, index]) => index)\n      .attr('fill', ([x, y, index]) => {\n        if (searchResultIndices[index]) return this.hoverColor\n        return 'white'\n      })\n  }\n\n  /** highlights the comment the user hovers over in the detail pane */\n  showHoveredComment() {\n    const { selected_datum, labels, allCoordinatesAsArray, clustersToShow, hoveredCommentCoordinate } = this.props\n    if (!this.svg || !labels || !this.group) return\n\n    var coordsToShow = allCoordinatesAsArray\n    if (coordsToShow.length === 0) return this.group.selectAll('circle').remove()\n\n    if (hoveredCommentCoordinate) coordsToShow.push([hoveredCommentCoordinate?.x, hoveredCommentCoordinate?.y, hoveredCommentCoordinate?.index])\n\n    this.group.selectAll('circle')\n      .data(coordsToShow, ([x, y, index]) => index)\n      .join(\n        enter => enter.append('circle')\n          .attr('fill', 'cyan')\n          .attr('fill-opacity', '1')\n          .attr('r', 1)\n          .attr('id', ([x, y, index]) => index)\n          .attr(\"cx\", ([x, y, index]) => x)\n          .attr(\"cy\", ([x, y, index]) => y)\n      )\n  }\n\n  /** zooms around so that cluster center is in the center of svg viewport and all clusters are visible */\n  zoomAroundCluster() {\n    if (!this.zoomBehavior) return\n    if (!this.svg) return\n    if (!this.props.selectedCluster) { // if unselected cluster, show overview\n      const scaleFactor = this.getInitScale(this.props.width, this.props.height)\n\n      this.svg?.transition()\n        .duration(1000)\n        .call(\n          this.zoomBehavior.transform,\n          d3.zoomIdentity.scale(scaleFactor.k)\n        )\n      return\n    }\n\n    const numNeighbors = this.props.coordinatesParameters.numNeighborsParameter\n    const minDist = this.props.coordinatesParameters.minDistParameter\n    if (!this.props.allCoordinatesFull?.[numNeighbors]?.[minDist]) return\n\n    const allCoordsOfSelectedCluster = this.props.labels?.filter(\n      (el, i) => (el.label_kmedoids === this.props.selectedCluster) ? true : false)\n      .map((el, i) => this.props.allCoordinatesFull?.[numNeighbors]?.[minDist]?.[i]!)\n\n    const mean_x = _.meanBy(allCoordsOfSelectedCluster, 'x') || 15\n    const mean_y = _.meanBy(allCoordsOfSelectedCluster, 'y') || 15\n    // TODO max x and max y, min x and min y, then scale factor just like below\n    // position where mean point is in the center of viewport\n    const mean_center_x = this.props.width / 2 - mean_x\n    const mean_center_y = this.props.height / 2 - mean_y\n    const delta_x = _.maxBy(allCoordsOfSelectedCluster, 'x')?.x || 0 - (_.minBy(allCoordsOfSelectedCluster, 'x')?.x || 0)\n    const delta_y = _.maxBy(allCoordsOfSelectedCluster, 'y')?.y || 0 - (_.minBy(allCoordsOfSelectedCluster, 'y')?.y || 0)\n    const scaleFactor = Math.min(this.props.width / delta_x, this.props.height / delta_y)\n\n    this.svg?.transition()\n      .duration(500)\n      .call(\n        this.zoomBehavior.translateTo,\n        mean_x, mean_y\n      )\n      .transition()\n      .duration(500)\n      .call(\n        this.zoomBehavior.scaleTo,\n        scaleFactor * 1.3\n      )\n\n  }\n\n  hasCommentClickedOnChanged(prevProps: PropsForProjection) {\n    return prevProps.selected_datum !== this.props.selected_datum\n  }\n\n  haveCoordinatesChanged(prevProps: PropsForProjection) {\n    return !_.isEqual(_.sortBy(prevProps.allCoordinates), _.sortBy(this.props.allCoordinates))\n  }\n\n  haveSearchResultsChanged(prevProps: PropsForProjection) {\n    return prevProps.searchResultIndices !== this.props.searchResultIndices\n  }\n\n  haveClustersToShowChanged(prevProps: PropsForProjection) {\n    return !_.isEqual(_.sortBy(prevProps.clustersToShow), _.sortBy(this.props.clustersToShow))\n  }\n\n  hasSelectedClusterChanged(prevProps: PropsForProjection) {\n    return prevProps.selectedCluster !== this.props.selectedCluster\n  }\n\n  hasHoveredCommentCoordinateChanged(prevProps: PropsForProjection) {\n    return prevProps.hoveredCommentCoordinate?.index !== this.props.hoveredCommentCoordinate?.index\n  }\n\n  componentDidUpdate(prevProps: PropsForProjection, prevState: {}) {\n    if (this.hasCommentClickedOnChanged(prevProps)) {\n      this.updateColorPoints()\n      return\n    }\n    if (this.hasSelectedClusterChanged(prevProps)) {\n      this.drawScatterPlot()\n      this.zoomAroundCluster()\n      return\n    }\n    if (this.haveClustersToShowChanged(prevProps) || this.haveCoordinatesChanged(prevProps)) {\n      this.drawScatterPlot()\n      return\n    }\n    if (this.haveSearchResultsChanged(prevProps)) return this.highlightSearchResults()\n    if (this.hasHoveredCommentCoordinateChanged(prevProps)) return this.showHoveredComment()\n  }\n\n  render() {\n    const { width, height } = this.props\n    return (\n      <svg ref={(ref) => this.ref = ref} width={width} height={height} overflow=\"hidden\"></svg>\n    )\n  }\n}\n\nexport default Projection\n","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/ProjectionElements/ProjectionParameters.tsx",["216","217","218"],"import React, { useState } from \"react\"\nimport { CircularProgress, makeStyles, Select, Theme, Typography } from '@material-ui/core'\nimport SlidersParamter from \"./Sliders\"\nimport { PropsFromData } from \"../Data\"\nimport { truncate } from \"lodash\"\nimport { PropsForProjection } from \"./Projection\"\nimport NativeSelect from \"@material-ui/core/NativeSelect\"\n\n\nconst useStyles = makeStyles<Theme, { width: number, isMouseOver: boolean }>(theme => ({\n    absoluteContainer: {\n        position: 'absolute',\n        margin: `0 ${theme.spacing(1)}`,\n        bottom: theme.spacing(2),\n        opacity: props => props.isMouseOver ? 1.0 : 0.2, // transparent until on mouse over\n        transition: 'opacity 0.1s',\n        display: 'flex',\n        flexWrap: 'wrap',\n        width: '100%'\n    },\n}))\n\ntype SelectOptions = 500 | 1000 | 2000\n\nexport default function ProjectionParameters(props: PropsForProjection) {\n    const [isMouseOver, setIsMouseOver] = useState(false)\n    const [optionSelected, selectOption] = useState(500 as SelectOptions)\n    const classes = useStyles({ width: props.width, isMouseOver: isMouseOver })\n\n    /*\n    <input name=\"numDataPoints\" type=\"text\" pattern=\"[0-9]*\"\n                    style={{ width: '4em', display: 'inline' }}\n                    value={coordinatesToLoad}\n                    onChange={(e) => {\n                        let size = parseInt(e.target.value) || 0\n                        setCoordinatesToLoad(size)\n                        setIsReloadingCoordinates(true)\n                        props.reloadCoordinatesWithSize(e, () => {\n                            setIsReloadingCoordinates(false)\n                        })\n                    }}\n                ></input>\n    */\n   \n    return (\n        <div className={classes.absoluteContainer}\n            onMouseEnter={() => setIsMouseOver(true)}\n            onMouseLeave={() => setIsMouseOver(false)}>\n            <SlidersParamter {...props} />\n            <div style={{ padding: '0 16px' }}>\n                <Typography variant=\"subtitle2\" style={{ display: 'inline', paddingRight: '16px' }}>\n                    Sample Size of Comments to Visualize\n                </Typography>\n                <NativeSelect\n                    value={optionSelected}\n                    onChange={(e) => {\n                        const size = parseInt(e.target.value) || 0\n                        selectOption(size as SelectOptions)\n                        props.reloadCoordinatesWithSize(size)\n                    }}\n                >\n                    <option value={500}>500</option>\n                    <option value={1000}>1000</option>\n                    <option value={2000}>2000 (slow)</option>\n                </NativeSelect>\n                {props.coordsAreReloading &&\n                    <CircularProgress style={{\n                        display: 'inline-block', marginLeft: '8px'\n                    }} size=\"1em\"></CircularProgress>\n                }\n            </div>\n        </div>\n    )\n}\n","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/ProjectionElements/Sliders.tsx",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/Comment.tsx",["219"],"import { Button, Card, CardActions, CardContent, makeStyles } from '@material-ui/core'\nimport Tooltip from '@material-ui/core/Tooltip'\nimport _ from 'lodash'\nimport React, { useState } from 'react'\nimport { DataPoint } from '../../Data'\nimport { PropsForSidebar } from '../../Sidebar'\nimport ClusterChangeCommentDialog from './ClusterChangeCommentDialog'\n\n\n/**\n * used inside sidebar to display one comment\n * elem is one data point\n */\n\nexport type CommentProps = {\n    dense?: boolean,\n    /** i the the index of the comment in prop data */\n    i: number,\n    /** callback of cluster change for this comment, or null if not changed */\n    onMoveCluster: (newLabel: string | null, i: number) => void,\n    /** is the comment the one of the representative */\n    isRepresentative?: boolean\n} & PropsForSidebar\n\nconst useStyles = makeStyles<any, { backgroundColor: string }>((theme) => ({\n    styleContainer: props => ({\n        display: 'block',\n        marginLeft: 0,\n        marginRight: 0,\n        marginBottom: theme.spacing(1),\n        backgroundColor: props.backgroundColor,\n        borderRadius: 0,\n    }),\n    styleMetaInfos: {\n        display: 'block',\n        width: '100%',\n        height: 'auto',\n    },\n    styleUsername: {\n        display: 'inline',\n        fontWeight: 'bold',\n        wordBreak: 'break-word'\n    },\n    styleComment: {\n        marginBottom: '0',\n        marginTop: '8px',\n        wordBreak: 'break-word'\n    },\n    styleDate: {\n        marginLeft: '8px',\n        display: 'inline',\n        color: 'LightGray',\n        fontStyle: 'italic',\n        fontSize: '0.9em',\n    },\n    btnsContainer: {\n        maxHeight: 0,\n        overflow: 'hidden',\n        transitionDelay: '0.2s',\n        transition: 'max-height 0.3s',\n        paddingRight: theme.spacing(3),\n        paddingLeft: theme.spacing(3),\n        width: '100%',\n    },\n    rightAlign: {\n        display: 'block',\n        marginLeft: 'auto',\n        marginRight: '0'\n    },\n    tooltip: {\n        fontSize: '0.8em',\n    }\n}))\n\n// styles for card content --> make denser\nconst useCardContentStyles = makeStyles(theme => ({\n    root: {\n        paddingTop: 8,\n        paddingBottom: 0,\n        paddingLeft: 16,\n        paddingRight: 16,\n    }\n}))\n\nexport default function Comment({ dense = false, data, i, onMoveCluster, added = false, removed = false, isRepresentative = false, ...other }: CommentProps) {\n    const backgroundColor: string = added ? '#1d3d17' : removed ? '#3d171b' : \"auto\"\n    const classes = useStyles({ backgroundColor: backgroundColor })\n    const cardContentStyles = useCardContentStyles()\n    const { publishedAt, authorName, cleaned } = data![i]\n    const [showClusterChangeDialog, setShowClusterChangeDialog] = useState(false)\n\n    const showPoint = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n        other.setHoveredCommentCoordinate(i)\n    }\n\n    const hidePoint = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n        other.setHoveredCommentCoordinate(null)\n    }\n\n    const dataPoint = _.find(other.dataChanged, ['i', i])\n\n    return (\n        <Card onMouseEnter={showPoint} onMouseLeave={hidePoint} className={classes.styleContainer}>\n            <CardContent classes={cardContentStyles}>\n                {dataPoint && <p style={{ marginLeft: 0 }} className={classes.styleDate}>{`from cluster ${dataPoint?.oldLabel.label_kmedoids} to ${dataPoint?.newLabel.label_kmedoids}`}</p>}\n                <div className={classes.styleMetaInfos}>\n                    <p className={classes.styleUsername}>{authorName}</p>\n                    <p className={classes.styleDate}>{publishedAt}</p>\n                </div>\n                <p className={classes.styleComment}>{cleaned}</p>\n            </CardContent>\n            <CardActions>\n                {isRepresentative\n                    ? (<Tooltip classes={{tooltip: classes.tootltip}} title=\"As this comment represents the whole cluster, it may not be moved. Use the Merge Clusters Field to merge the whole cluster with another.\">\n                        <span><Button onClick={() => null} disabled>Move to other Cluster</Button></span>\n                    </Tooltip>)\n                    : <Button onClick={() => setShowClusterChangeDialog(true)}>Move to other Cluster</Button>\n                }\n            </CardActions>\n            <ClusterChangeCommentDialog\n                open={showClusterChangeDialog}\n                onMoveCluster={(clusterSelected) => {\n                    setShowClusterChangeDialog(false)\n                    onMoveCluster(clusterSelected, i)\n                }}\n                i={i}\n                data={data}\n                {...other}\n            />\n        </Card>\n    )\n}","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/ClusterChangeCommentDialog.tsx",["220","221","222","223","224","225","226","227"],"import React from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport Button from '@material-ui/core/Button';\nimport Avatar from '@material-ui/core/Avatar';\nimport List from '@material-ui/core/List';\nimport ListItem from '@material-ui/core/ListItem';\nimport ListItemAvatar from '@material-ui/core/ListItemAvatar';\nimport ListItemText from '@material-ui/core/ListItemText';\nimport DialogTitle from '@material-ui/core/DialogTitle';\nimport Dialog from '@material-ui/core/Dialog';\nimport PersonIcon from '@material-ui/icons/Person';\nimport AddIcon from '@material-ui/icons/Add';\nimport Typography from '@material-ui/core/Typography';\nimport { blue } from '@material-ui/core/colors';\nimport ListSubheader from '@material-ui/core/ListSubheader';\nimport Data, { Label } from '../../Data';\nimport { CommentProps } from './Comment';\nimport _ from 'lodash';\n\nconst emails = ['username@gmail.com', 'user02@gmail.com'];\nconst useStyles = makeStyles({\n    avatar: {\n        backgroundColor: blue[100],\n        color: blue[600],\n    },\n});\n\n\ntype ClusterChangeCommentDialogProps = {\n    open: boolean,\n} & CommentProps\n\n\nexport default function ClusterChangeCommentDialog({\n    open,\n    data,\n    labels,\n    clustersToShow,\n    clusters,\n    onClose,\n    i,\n    selectedCluster,\n    onMoveCluster,\n    ...other\n}: ClusterChangeCommentDialogProps) {\n    const classes = useStyles();\n\n    const remainingClusters = _.without(Object.keys(clusters), ...clustersToShow)\n\n    return (\n        <Dialog onClose={() => onMoveCluster(null, i)} aria-labelledby=\"dialog for changing the cluster of the selected comment\" open={open}>\n            <DialogTitle>Change Cluster</DialogTitle>\n            <List>\n                <ListSubheader component=\"div\" id=\"nested-list-subheader\" disableSticky>Selected Cluster</ListSubheader>\n                <ListItem onClick={() => onMoveCluster(selectedCluster, i)} button key={`clusterpicker-${-1}`}>\n                    <ListItemText primary={selectedCluster} secondary={`size: ${clusters[selectedCluster || \"\"]?.size}    density: ${clusters[selectedCluster || \"\"]?.quality.toFixed(3)}`} />\n                </ListItem>\n                <ListSubheader component=\"div\" id=\"nested-list-subheader\" disableSticky>Visible Clusters</ListSubheader>\n                {\n                    clustersToShow.map((cluster: string) => {\n                        if (cluster === labels![i].label_kmedoids) return\n                        return (\n                            <ListItem onClick={() => onMoveCluster(cluster, i)} button key={`clusterpicker-${cluster}`}>\n                                <ListItemText primary={cluster} secondary={`size: ${clusters[cluster]?.size || 'N/A'}    density: ${clusters[cluster]?.quality.toFixed(3) || 'N/A'}`} />\n                            </ListItem>)\n                    })\n                }\n                <ListSubheader component=\"div\" id=\"nested-list-subheader\" disableSticky>Other Clusters</ListSubheader>\n                {\n                    remainingClusters.map((cluster: string) => (\n                        <ListItem onClick={() => onMoveCluster(cluster, i)} button key={`clusterpicker-${cluster}`}>\n                            <ListItemText primary={cluster} secondary={`size: ${clusters[cluster].size}    density: ${clusters[cluster].quality.toFixed(3)}`} />\n                        </ListItem>)\n                    )\n                }\n                <ListItem onClick={() => onMoveCluster('new', i)} autoFocus button>\n                    <ListItemAvatar>\n                        <Avatar>\n                            <AddIcon />\n                        </Avatar>\n                    </ListItemAvatar>\n                    <ListItemText primary=\"Add to new Cluster\" secondary={'The name of the new cluster is \"new\" by default'}/>\n                </ListItem>\n            </List>\n        </Dialog>\n    )\n}","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Sidebar2.tsx",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/ListItemComment.tsx",["228","229","230","231","232"],"import { Button, Card, CardActions, CardContent, Divider, ListItem, ListItemSecondaryAction, ListItemText, makeStyles, Typography } from '@material-ui/core'\nimport Tooltip from '@material-ui/core/Tooltip'\nimport _ from 'lodash'\nimport React, { useState } from 'react'\nimport { DataPoint } from '../../Data'\nimport { PropsForSidebar } from '../../Sidebar'\nimport ClusterChangeCommentDialog from './ClusterChangeCommentDialog'\n\n\nexport type CommentProps = {\n    /** the datapoint to show */\n    d: DataPoint\n    /** i the the index of the comment in prop data */\n    i: number,\n    /** callback of cluster change for this comment, or null if not changed */\n    onMoveCluster: (newLabel: string | null, i: number) => void,\n    /** is the comment the one of the representative */\n    isRepresentative?: boolean\n} & PropsForSidebar\n\nconst useStyles = makeStyles(theme => ({\n    inline: {\n        display: 'inline',\n    },\n    // secondary list actions are positioned absolutely in material-ui\n    // this style is applied to the other (!) elements if secondary\n    // action is used\n    secondaryAction: {\n        paddingRight: '80px'\n    },\n}))\n\nexport default function ListItemComment(props: CommentProps) {\n    const classes = useStyles()\n    const [showClusterChangeDialog, setShowClusterChangeDialog] = useState(false)\n\n    const showPoint = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n        props.setHoveredCommentCoordinate(props.i)\n    }\n\n    const hidePoint = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n        props.setHoveredCommentCoordinate(null)\n    }\n\n    return (\n        <>\n            <ListItem key={props.d.i} classes={{ secondaryAction: classes.secondaryAction }}>\n                <ListItemText\n                    onMouseEnter={showPoint}\n                    onMouseLeave={hidePoint}\n                    primary={props.d.authorName}\n                    secondary={\n                        <>\n                            <Typography\n                                component=\"span\"\n                                variant=\"body2\"\n                                className={classes.inline}\n                                style={{wordBreak: 'break-word'}}\n                            >\n                                {`${props.d.publishedAt} - `}\n                            </Typography>\n                            <Typography\n                                component=\"span\"\n                                variant=\"body2\"\n                                color=\"textPrimary\"\n                                style={{wordBreak: 'break-word'}}\n                            >\n                                {props.d.cleaned}\n                            </Typography>\n                        </>\n                    }\n                />\n                <ListItemSecondaryAction>\n                    <Button onClick={() => setShowClusterChangeDialog(true)}>Move</Button>\n                </ListItemSecondaryAction>\n            </ListItem>\n            <Divider />\n            <ClusterChangeCommentDialog\n                {...props}\n                open={showClusterChangeDialog}\n                onMoveCluster={(clusterSelected) => {\n                    setShowClusterChangeDialog(false)\n                    props.onMoveCluster(clusterSelected, props.i)\n                }}\n                i={props.i}\n                data={props.data}\n            />\n        </>\n    )\n}",{"ruleId":"233","replacedBy":"234"},{"ruleId":"235","replacedBy":"236"},{"ruleId":"237","severity":1,"message":"238","line":7,"column":17,"nodeType":"239","messageId":"240","endLine":7,"endColumn":18},{"ruleId":"233","replacedBy":"241"},{"ruleId":"235","replacedBy":"242"},{"ruleId":"233","replacedBy":"243"},{"ruleId":"235","replacedBy":"244"},{"ruleId":"237","severity":1,"message":"245","line":42,"column":11,"nodeType":"239","messageId":"240","endLine":42,"endColumn":18},{"ruleId":"246","severity":1,"message":"247","line":2,"column":41,"nodeType":"239","messageId":"240","endLine":2,"endColumn":46},{"ruleId":"246","severity":1,"message":"248","line":4,"column":8,"nodeType":"239","messageId":"240","endLine":4,"endColumn":17},{"ruleId":"246","severity":1,"message":"249","line":6,"column":8,"nodeType":"239","messageId":"240","endLine":6,"endColumn":16},{"ruleId":"246","severity":1,"message":"250","line":8,"column":8,"nodeType":"239","messageId":"240","endLine":8,"endColumn":20},{"ruleId":"246","severity":1,"message":"251","line":9,"column":10,"nodeType":"239","messageId":"240","endLine":9,"endColumn":13},{"ruleId":"246","severity":1,"message":"252","line":9,"column":15,"nodeType":"239","messageId":"240","endLine":9,"endColumn":19},{"ruleId":"246","severity":1,"message":"253","line":9,"column":21,"nodeType":"239","messageId":"240","endLine":9,"endColumn":32},{"ruleId":"246","severity":1,"message":"254","line":9,"column":34,"nodeType":"239","messageId":"240","endLine":9,"endColumn":42},{"ruleId":"246","severity":1,"message":"255","line":9,"column":44,"nodeType":"239","messageId":"240","endLine":9,"endColumn":67},{"ruleId":"246","severity":1,"message":"256","line":10,"column":8,"nodeType":"239","messageId":"240","endLine":10,"endColumn":34},{"ruleId":"246","severity":1,"message":"257","line":12,"column":10,"nodeType":"239","messageId":"240","endLine":12,"endColumn":15},{"ruleId":"246","severity":1,"message":"258","line":14,"column":8,"nodeType":"239","messageId":"240","endLine":14,"endColumn":20},{"ruleId":"246","severity":1,"message":"259","line":15,"column":8,"nodeType":"239","messageId":"240","endLine":15,"endColumn":15},{"ruleId":"260","severity":1,"message":"261","line":60,"column":55,"nodeType":"262","messageId":"263","endLine":60,"endColumn":57},{"ruleId":"260","severity":1,"message":"264","line":70,"column":75,"nodeType":"262","messageId":"263","endLine":70,"endColumn":77},{"ruleId":"265","severity":1,"message":"266","line":76,"column":8,"nodeType":"267","endLine":76,"endColumn":25,"suggestions":"268"},{"ruleId":"269","severity":1,"message":"270","line":98,"column":29,"nodeType":"271","messageId":"272","endLine":98,"endColumn":35},{"ruleId":"260","severity":1,"message":"264","line":124,"column":48,"nodeType":"262","messageId":"263","endLine":124,"endColumn":50},{"ruleId":"260","severity":1,"message":"264","line":125,"column":48,"nodeType":"262","messageId":"263","endLine":125,"endColumn":50},{"ruleId":"260","severity":1,"message":"264","line":126,"column":52,"nodeType":"262","messageId":"263","endLine":126,"endColumn":54},{"ruleId":"260","severity":1,"message":"264","line":127,"column":52,"nodeType":"262","messageId":"263","endLine":127,"endColumn":54},{"ruleId":"233","replacedBy":"234"},{"ruleId":"235","replacedBy":"236"},{"ruleId":"246","severity":1,"message":"273","line":1,"column":10,"nodeType":"239","messageId":"240","endLine":1,"endColumn":19},{"ruleId":"274","severity":1,"message":"275","line":200,"column":23,"nodeType":"276","messageId":"277","endLine":200,"endColumn":25},{"ruleId":"260","severity":1,"message":"261","line":200,"column":66,"nodeType":"262","messageId":"263","endLine":200,"endColumn":68},{"ruleId":"274","severity":1,"message":"275","line":201,"column":7,"nodeType":"276","messageId":"277","endLine":201,"endColumn":9},{"ruleId":"274","severity":1,"message":"278","line":201,"column":7,"nodeType":"276","messageId":"277","endLine":201,"endColumn":9},{"ruleId":"274","severity":1,"message":"278","line":201,"column":27,"nodeType":"276","messageId":"277","endLine":201,"endColumn":29},{"ruleId":"260","severity":1,"message":"261","line":201,"column":62,"nodeType":"262","messageId":"263","endLine":201,"endColumn":64},{"ruleId":"260","severity":1,"message":"261","line":244,"column":20,"nodeType":"262","messageId":"263","endLine":244,"endColumn":22},{"ruleId":"260","severity":1,"message":"264","line":518,"column":63,"nodeType":"262","messageId":"263","endLine":518,"endColumn":65},{"ruleId":"269","severity":1,"message":"270","line":518,"column":73,"nodeType":"271","messageId":"272","endLine":518,"endColumn":79},{"ruleId":"246","severity":1,"message":"279","line":121,"column":9,"nodeType":"239","messageId":"240","endLine":121,"endColumn":20},{"ruleId":"246","severity":1,"message":"280","line":133,"column":9,"nodeType":"239","messageId":"240","endLine":133,"endColumn":18},{"ruleId":"246","severity":1,"message":"281","line":1,"column":17,"nodeType":"239","messageId":"240","endLine":1,"endColumn":31},{"ruleId":"246","severity":1,"message":"282","line":2,"column":8,"nodeType":"239","messageId":"240","endLine":2,"endColumn":22},{"ruleId":"246","severity":1,"message":"283","line":6,"column":10,"nodeType":"239","messageId":"240","endLine":6,"endColumn":19},{"ruleId":"246","severity":1,"message":"284","line":63,"column":11,"nodeType":"239","messageId":"240","endLine":63,"endColumn":17},{"ruleId":"246","severity":1,"message":"285","line":29,"column":6,"nodeType":"239","messageId":"240","endLine":29,"endColumn":21},{"ruleId":"246","severity":1,"message":"286","line":36,"column":5,"nodeType":"239","messageId":"240","endLine":36,"endColumn":18},{"ruleId":"246","severity":1,"message":"287","line":273,"column":11,"nodeType":"239","messageId":"240","endLine":273,"endColumn":20},{"ruleId":"246","severity":1,"message":"288","line":3,"column":8,"nodeType":"239","messageId":"240","endLine":3,"endColumn":18},{"ruleId":"246","severity":1,"message":"289","line":4,"column":10,"nodeType":"239","messageId":"240","endLine":4,"endColumn":14},{"ruleId":"246","severity":1,"message":"290","line":5,"column":10,"nodeType":"239","messageId":"240","endLine":5,"endColumn":22},{"ruleId":"246","severity":1,"message":"291","line":5,"column":54,"nodeType":"239","messageId":"240","endLine":5,"endColumn":61},{"ruleId":"246","severity":1,"message":"292","line":7,"column":17,"nodeType":"239","messageId":"240","endLine":7,"endColumn":26},{"ruleId":"246","severity":1,"message":"293","line":7,"column":28,"nodeType":"239","messageId":"240","endLine":7,"endColumn":36},{"ruleId":"246","severity":1,"message":"294","line":2,"column":10,"nodeType":"239","messageId":"240","endLine":2,"endColumn":17},{"ruleId":"246","severity":1,"message":"283","line":2,"column":32,"nodeType":"239","messageId":"240","endLine":2,"endColumn":41},{"ruleId":"246","severity":1,"message":"295","line":4,"column":8,"nodeType":"239","messageId":"240","endLine":4,"endColumn":17},{"ruleId":"246","severity":1,"message":"250","line":5,"column":8,"nodeType":"239","messageId":"240","endLine":5,"endColumn":20},{"ruleId":"233","replacedBy":"296"},{"ruleId":"235","replacedBy":"297"},{"ruleId":"246","severity":1,"message":"298","line":1,"column":10,"nodeType":"239","messageId":"240","endLine":1,"endColumn":25},{"ruleId":"246","severity":1,"message":"283","line":3,"column":10,"nodeType":"239","messageId":"240","endLine":3,"endColumn":19},{"ruleId":"246","severity":1,"message":"295","line":5,"column":8,"nodeType":"239","messageId":"240","endLine":5,"endColumn":17},{"ruleId":"233","replacedBy":"299"},{"ruleId":"235","replacedBy":"300"},{"ruleId":"260","severity":1,"message":"264","line":65,"column":68,"nodeType":"262","messageId":"263","endLine":65,"endColumn":70},{"ruleId":"260","severity":1,"message":"264","line":73,"column":68,"nodeType":"262","messageId":"263","endLine":73,"endColumn":70},{"ruleId":"246","severity":1,"message":"301","line":5,"column":13,"nodeType":"239","messageId":"240","endLine":5,"endColumn":17},{"ruleId":"246","severity":1,"message":"302","line":5,"column":19,"nodeType":"239","messageId":"240","endLine":5,"endColumn":28},{"ruleId":"246","severity":1,"message":"303","line":50,"column":7,"nodeType":"239","messageId":"240","endLine":50,"endColumn":21},{"ruleId":"246","severity":1,"message":"303","line":147,"column":60,"nodeType":"239","messageId":"240","endLine":147,"endColumn":74},{"ruleId":"260","severity":1,"message":"261","line":157,"column":19,"nodeType":"262","messageId":"263","endLine":157,"endColumn":21},{"ruleId":"260","severity":1,"message":"261","line":158,"column":40,"nodeType":"262","messageId":"263","endLine":158,"endColumn":42},{"ruleId":"246","severity":1,"message":"304","line":165,"column":13,"nodeType":"239","messageId":"240","endLine":165,"endColumn":27},{"ruleId":"246","severity":1,"message":"305","line":165,"column":29,"nodeType":"239","messageId":"240","endLine":165,"endColumn":35},{"ruleId":"246","severity":1,"message":"306","line":165,"column":37,"nodeType":"239","messageId":"240","endLine":165,"endColumn":48},{"ruleId":"246","severity":1,"message":"303","line":165,"column":94,"nodeType":"239","messageId":"240","endLine":165,"endColumn":108},{"ruleId":"246","severity":1,"message":"304","line":179,"column":13,"nodeType":"239","messageId":"240","endLine":179,"endColumn":27},{"ruleId":"246","severity":1,"message":"303","line":179,"column":60,"nodeType":"239","messageId":"240","endLine":179,"endColumn":74},{"ruleId":"246","severity":1,"message":"307","line":228,"column":11,"nodeType":"239","messageId":"240","endLine":228,"endColumn":24},{"ruleId":"246","severity":1,"message":"308","line":229,"column":11,"nodeType":"239","messageId":"240","endLine":229,"endColumn":24},{"ruleId":"246","severity":1,"message":"309","line":2,"column":40,"nodeType":"239","messageId":"240","endLine":2,"endColumn":46},{"ruleId":"246","severity":1,"message":"310","line":4,"column":10,"nodeType":"239","messageId":"240","endLine":4,"endColumn":23},{"ruleId":"246","severity":1,"message":"311","line":5,"column":10,"nodeType":"239","messageId":"240","endLine":5,"endColumn":18},{"ruleId":"246","severity":1,"message":"283","line":5,"column":10,"nodeType":"239","messageId":"240","endLine":5,"endColumn":19},{"ruleId":"246","severity":1,"message":"312","line":3,"column":8,"nodeType":"239","messageId":"240","endLine":3,"endColumn":14},{"ruleId":"246","severity":1,"message":"313","line":11,"column":8,"nodeType":"239","messageId":"240","endLine":11,"endColumn":18},{"ruleId":"246","severity":1,"message":"314","line":13,"column":8,"nodeType":"239","messageId":"240","endLine":13,"endColumn":18},{"ruleId":"246","severity":1,"message":"315","line":16,"column":8,"nodeType":"239","messageId":"240","endLine":16,"endColumn":12},{"ruleId":"246","severity":1,"message":"247","line":16,"column":16,"nodeType":"239","messageId":"240","endLine":16,"endColumn":21},{"ruleId":"246","severity":1,"message":"316","line":20,"column":7,"nodeType":"239","messageId":"240","endLine":20,"endColumn":13},{"ruleId":"246","severity":1,"message":"317","line":46,"column":11,"nodeType":"239","messageId":"240","endLine":46,"endColumn":18},{"ruleId":"269","severity":1,"message":"270","line":61,"column":68,"nodeType":"271","messageId":"272","endLine":61,"endColumn":74},{"ruleId":"246","severity":1,"message":"252","line":1,"column":18,"nodeType":"239","messageId":"240","endLine":1,"endColumn":22},{"ruleId":"246","severity":1,"message":"318","line":1,"column":24,"nodeType":"239","messageId":"240","endLine":1,"endColumn":35},{"ruleId":"246","severity":1,"message":"253","line":1,"column":37,"nodeType":"239","messageId":"240","endLine":1,"endColumn":48},{"ruleId":"246","severity":1,"message":"291","line":2,"column":8,"nodeType":"239","messageId":"240","endLine":2,"endColumn":15},{"ruleId":"246","severity":1,"message":"319","line":3,"column":8,"nodeType":"239","messageId":"240","endLine":3,"endColumn":9},"no-native-reassign",["320"],"no-negated-in-lhs",["321"],"no-unused-vars","'p' is assigned a value but never used.","Identifier","unusedVar",["320"],["321"],["320"],["321"],"'onClick' is assigned a value but never used.","@typescript-eslint/no-unused-vars","'Label' is defined but never used.","'Separator' is defined but never used.","'MetaInfo' is defined but never used.","'NeoMorphCard' is defined but never used.","'Box' is defined but never used.","'Card' is defined but never used.","'CardContent' is defined but never used.","'ListItem' is defined but never used.","'ListItemSecondaryAction' is defined but never used.","'ClusterChangeCommentDialog' is defined but never used.","'index' is defined but never used.","'ListItemText' is defined but never used.","'Divider' is defined but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'labelLocal' and 'props'. Either include them or remove the dependency array. However, 'props' will change when *any* prop changes, so the preferred fix is to destructure the 'props' object outside of the useEffect call and refer to those specific props inside useEffect.","ArrayExpression",["322"],"array-callback-return","Array.prototype.map() expects a return value from arrow function.","ReturnStatement","expectedReturnValue","'constants' is defined but never used.","no-mixed-operators","Unexpected mix of '&&' and '||'.","LogicalExpression","unexpectedMixedOperator","Unexpected mix of '||' and '&&'.","'line_height' is assigned a value but never used.","'font_size' is assigned a value but never used.","'SetStateAction' is defined but never used.","'ClusterSnippet' is defined but never used.","'DataPoint' is defined but never used.","'legend' is assigned a value but never used.","'ClusterInfoDict' is defined but never used.","'labelsAndData' is assigned a value but never used.","'emptyRows' is assigned a value but never used.","'IconButton' is defined but never used.","'Save' is defined but never used.","'createStyles' is defined but never used.","'Tooltip' is defined but never used.","'useEffect' is defined but never used.","'useState' is defined but never used.","'Cluster' is defined but never used.","'TextField' is defined but never used.",["320"],["321"],"'PropsForSidebar' is defined but never used.",["320"],["321"],"'join' is defined but never used.","'stubFalse' is defined but never used.","'clustersToShow' is assigned a value but never used.","'selected_datum' is assigned a value but never used.","'labels' is assigned a value but never used.","'labelChoice' is assigned a value but never used.","'mean_center_x' is assigned a value but never used.","'mean_center_y' is assigned a value but never used.","'Select' is defined but never used.","'PropsFromData' is defined but never used.","'truncate' is defined but never used.","'Button' is defined but never used.","'PersonIcon' is defined but never used.","'Typography' is defined but never used.","'Data' is defined but never used.","'emails' is assigned a value but never used.","'classes' is assigned a value but never used.","'CardActions' is defined but never used.","'_' is defined but never used.","no-global-assign","no-unsafe-negation",{"desc":"323","fix":"324"},"Update the dependencies array to be: [labelLocal, props, selectedCluster]",{"range":"325","text":"326"},[2998,3015],"[labelLocal, props, selectedCluster]"]