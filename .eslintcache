[{"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/index.js":"1","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/App.js":"2","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/serviceWorker.js":"3","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/About.js":"4","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Content.js":"5","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/Separator.js":"6","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/Select.js":"7","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Store.js":"8","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterOverview/ClusterSnippet.js":"9","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/index.js":"10","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/ClusterDetailsLayout.tsx":"11","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Data.tsx":"12","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Layout.tsx":"13","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Sidebar.tsx":"14","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterOverview/ClusterOverview.tsx":"15","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterOverview/ClusterTable.tsx":"16","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/ClusterMenu.tsx":"17","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/MetaInfo.tsx":"18","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/NeoMorphCard.tsx":"19","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterMerger.tsx":"20","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/ProjectionElements/Projection.tsx":"21","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/ProjectionElements/ProjectionParameters.tsx":"22","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/ProjectionElements/Sliders.tsx":"23","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/Comment.tsx":"24","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/ClusterChangeCommentDialog.tsx":"25","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/DragBar.tsx":"26"},{"size":451,"mtime":1607874062990,"results":"27","hashOfConfig":"28"},{"size":437,"mtime":1610987370591,"results":"29","hashOfConfig":"28"},{"size":4948,"mtime":1607874062991,"results":"30","hashOfConfig":"28"},{"size":1570,"mtime":1607874062988,"results":"31","hashOfConfig":"28"},{"size":9278,"mtime":1607874062988,"results":"32","hashOfConfig":"28"},{"size":519,"mtime":1609349848460,"results":"33","hashOfConfig":"28"},{"size":753,"mtime":1609877020615,"results":"34","hashOfConfig":"28"},{"size":978,"mtime":1610638122448,"results":"35","hashOfConfig":"28"},{"size":1563,"mtime":1610662485820,"results":"36","hashOfConfig":"28"},{"size":185,"mtime":1611271763856,"results":"37","hashOfConfig":"28"},{"size":4998,"mtime":1612016309855,"results":"38","hashOfConfig":"28"},{"size":16337,"mtime":1612056508771,"results":"39","hashOfConfig":"28"},{"size":5658,"mtime":1612468311985,"results":"40","hashOfConfig":"28"},{"size":1811,"mtime":1612451312831,"results":"41","hashOfConfig":"28"},{"size":482,"mtime":1611936423069,"results":"42","hashOfConfig":"28"},{"size":13426,"mtime":1612458778847,"results":"43","hashOfConfig":"28"},{"size":1707,"mtime":1612025157152,"results":"44","hashOfConfig":"28"},{"size":1277,"mtime":1612014720566,"results":"45","hashOfConfig":"28"},{"size":904,"mtime":1611278770069,"results":"46","hashOfConfig":"28"},{"size":3967,"mtime":1612025157152,"results":"47","hashOfConfig":"28"},{"size":7739,"mtime":1612139137412,"results":"48","hashOfConfig":"28"},{"size":2499,"mtime":1611845611009,"results":"49","hashOfConfig":"28"},{"size":3010,"mtime":1611787386354,"results":"50","hashOfConfig":"28"},{"size":3692,"mtime":1612056681818,"results":"51","hashOfConfig":"28"},{"size":3852,"mtime":1612025530498,"results":"52","hashOfConfig":"28"},{"size":680,"mtime":1612468311985,"results":"53","hashOfConfig":"28"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},"mxeu8k",{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"63","usedDeprecatedRules":"64"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"64"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"69"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"64"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"74","messages":"75","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76","usedDeprecatedRules":"64"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"56"},{"filePath":"79","messages":"80","errorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"81","usedDeprecatedRules":"82"},{"filePath":"83","messages":"84","errorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"85","usedDeprecatedRules":"82"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"88","messages":"89","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"90","messages":"91","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"92","usedDeprecatedRules":"82"},{"filePath":"93","messages":"94","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"95","usedDeprecatedRules":"82"},{"filePath":"96","messages":"97","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"98","usedDeprecatedRules":"82"},{"filePath":"99","messages":"100","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"101","usedDeprecatedRules":"82"},{"filePath":"102","messages":"103","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"104","usedDeprecatedRules":"105"},{"filePath":"106","messages":"107","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"108","usedDeprecatedRules":"82"},{"filePath":"109","messages":"110","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"111","usedDeprecatedRules":"82"},{"filePath":"112","messages":"113","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"114","usedDeprecatedRules":"82"},{"filePath":"115","messages":"116","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"117","usedDeprecatedRules":"82"},{"filePath":"118","messages":"119","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"120","usedDeprecatedRules":"82"},{"filePath":"121","messages":"122","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"123","usedDeprecatedRules":"82"},{"filePath":"124","messages":"125","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/index.js",[],["126","127"],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/App.js",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/serviceWorker.js",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/About.js",["128"],"import React, { Component } from 'react'\nimport Markdown from 'react-remarkable'\nimport { about_text } from './Content'\n\nclass About extends Component {\n  render() {\n    let { grem, p } = this.props\n    return (\n      <div\n        style={{\n          position: 'fixed',\n          left: 0,\n          top: 0,\n          right: 0,\n          bottom: 0,\n          background: '#222',\n          color: '#fff',\n          paddingTop: grem * 2,\n          overflowY: 'auto',\n          fontSize: 16,\n          lineHeight: 1.5,\n        }}\n      >\n        <div\n          style={{\n            background: '#333',\n            position: 'fixed',\n            left: 0,\n            top: 0,\n            right: 0,\n            padding: grem / 2,\n          }}\n        >\n          About\n          <button\n            onClick={() => {\n              this.props.toggleAbout(false)\n            }}\n            className=\"hover-555\"\n            style={{\n              position: 'absolute',\n              right: 0,\n              top: 0,\n              height: grem * 2,\n              width: grem * 2,\n              padding: grem / 2,\n              textAlign: 'center',\n              cursor: 'pointer',\n              textDecoration: 'none',\n            }}\n          >\n            &times;\n          </button>\n        </div>\n        <div\n          style={{\n            maxWidth: grem * 30,\n            margin: '0 auto',\n            padding: grem / 2,\n            color: '#fff',\n          }}\n        >\n          <Markdown>{about_text}</Markdown>\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default About\n",["129","130"],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Content.js",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/Separator.js",[],["131","132"],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/Select.js",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Store.js",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterOverview/ClusterSnippet.js",["133"],"import React from 'react';\nimport { createUseStyles } from 'react-jss'\n\nconst useStyles = createUseStyles(\n    {\n        card: {\n            display: 'block',\n            margin: '32px 24px',\n            padding: '4px 16px',\n            position: 'relative',\n            transition: 'all .2s ease-in-out',\n            '&:hover': {\n                boxShadow: '0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)',\n                marginBottom: '54px'\n            }\n        },\n        neomorphism: {\n            borderRadius: '15px',\n            background: 'linear-gradient(145deg, #373737, #2e2e2e)',\n            boxShadow: '5px 5px 12px #181818, -5px -5px 12px #4e4e4e'\n        },\n        p: {\n            display: 'inline-block',\n            marginBlockStart: '1em',\n            marginBlockEnd: '1em',\n            marginInlineStart: '0px',\n            marginInlineEnd: '1em',\n        },\n    })\n\n/**\n * \n * @param comments is the subset of the data which has label @param label\n * @param label is the label of said comments\n */\nexport default function ClusterSnippet({ label, labels, data, ...otherProps }) {\n    const classes = useStyles()\n\n    const correctLabels = labels.filter(({ label_kmedoids, label_kmeans }) => label_kmedoids === label)\n    const size = correctLabels.length\n\n    const onClick = (e) => null\n\n    return (\n\n        <div className={`${classes.neomorphism} ${classes.card}`}>\n            <h3>{label}</h3>\n            <p className={classes.p}>Size: {size}</p>\n            <p className={classes.p}>Density: 41</p>\n        </div>\n    )\n}","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/index.js",[],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/ClusterDetailsLayout.tsx",["134","135","136","137","138","139","140","141","142","143","144","145","146","147","148"],"import React, { useState, useEffect } from 'react'\nimport { DataPoint, Label } from '../../Data'\nimport { PropsForSidebar } from '../../Sidebar'\nimport Separator from '../Separator'\nimport ClusterMenu from './ClusterMenu'\nimport MetaInfo from './MetaInfo'\nimport Comment from './Comment'\nimport NeoMorphCard from './NeoMorphCard'\nimport { Box, Card, CardContent, makeStyles, Typography } from '@material-ui/core'\nimport ClusterChangeCommentDialog from './ClusterChangeCommentDialog'\nimport _ from 'lodash'\nimport { index } from 'd3'\n\n\ntype ClusterDetailsLayoutProps = PropsForSidebar\n\nexport default function ClusterDetailsLayout(props: ClusterDetailsLayoutProps) {\n    const { data, dataChanged, pushToDataChanged, labels, selected_datum, selectedCluster } = props\n    const [labelLocal, setLabelLocal] = useState(selectedCluster || \"\")\n    // select only unchanged data of cluster, without selected point\n    const dataOfCluster = data!.filter((d, i) => {\n        if (labels === null) return false\n        const hasChangedAlready = _.find(dataChanged, ['i', d.i]) // undefined if not found\n        const isSelectedDatum = (i === selected_datum)\n        const sameCluster = (labels[i].label_kmedoids == selectedCluster)\n        return !hasChangedAlready && sameCluster && !isSelectedDatum\n    })\n    // select all data that was added to this cluster\n    const dataAddedToThisCluster = dataChanged.filter(el => el.newLabel.label_kmedoids === selectedCluster)\n    // select all data that was removed from this cluster\n    const dataRemovedFromThisCluster = dataChanged.filter(el => el.oldLabel.label_kmedoids === selectedCluster)\n\n    useEffect(() => {\n        if (selectedCluster) {\n            setLabelLocal(selectedCluster)\n        }\n    }, [selectedCluster])\n\n    const onMoveCluster = (newLabel: string | null, i: number) => {\n        if (!newLabel || !labels) return\n        pushToDataChanged({\n            ...data![i],\n            oldLabel: labels[i],\n            newLabel: { label_kmedoids: newLabel }\n        })\n    }\n\n    /**\n     * \n     * @param data \n     * @param type \"normal\" | \"added\" | \"removed\"\n     */\n    const buildComments = (data: DataPoint[], type: 'normal' | \"added\" | \"removed\") => {\n        return data.map((element, index) => {\n            if (index > 20) return\n            return (\n                <Comment onMoveCluster={onMoveCluster} i={element.i} key={`cluster-peer-${index}`}\n                    {...type === 'added' ? { added: true } : type === 'removed' ? { removed: true } : {}}\n                    {...props} dense />\n            )\n        })\n    }\n\n    const buildHeadline = (headline: string) => (\n        <Typography style={{ padding: '5%' }} variant='h5'>{headline}</Typography>\n    )\n\n    const hasRepresentative = props.selectedCluster && props.clusters[props.selectedCluster].medoid\n    const otherRepresentatives = props.selectedCluster && props.clusters[props.selectedCluster].representatives.length > 0\n\n    return (\n        (selectedCluster) ?\n            (<>\n                <ClusterMenu labelLocal={labelLocal!} setLabelLocal={setLabelLocal} {...props} />\n                {dataAddedToThisCluster.length != 0 && buildHeadline('Added to this Cluster')}\n                {dataAddedToThisCluster.length != 0 && buildComments(dataAddedToThisCluster as DataPoint[], 'added')}\n                {dataRemovedFromThisCluster.length != 0 && buildHeadline('Removed from this Cluster')}\n                {dataRemovedFromThisCluster.length != 0 && buildComments(dataRemovedFromThisCluster as DataPoint[], 'removed')}\n                {buildHeadline('Cluster-infos')}\n                <MetaInfo selectedClusterInfo={props.clusters[selectedCluster]} {...props} />\n                {hasRepresentative && buildHeadline('Cluster-Representative')}\n                {hasRepresentative && <Comment onMoveCluster={onMoveCluster} i={props.clusters[props.selectedCluster!].medoid || 0} {...props} />}\n                {otherRepresentatives && buildHeadline('Overview-Comments')}\n                {otherRepresentatives && props.clusters[props.selectedCluster!].representatives.map(\n                    reprs_index => (\n                        <Comment key={`representative-${reprs_index}`} onMoveCluster={onMoveCluster} i={reprs_index} {...props} />\n                    )\n                )}\n                <div style={{\n                    display: 'flex',\n                    flexDirection: (props.sidebar_orientation === 'horizontal') ? 'row' : 'column',\n                }}\n                >\n                    {selected_datum && (\n                        <>\n                            {buildHeadline('Selected Comment')}\n                            <Comment onMoveCluster={onMoveCluster} i={selected_datum} {...props} />\n                        </>\n                    )}\n                    {buildHeadline('Other comments')}\n                    {buildComments(dataOfCluster, 'normal')}\n                </div>\n            </>)\n            : <p>No Cluster selected</p>\n    )\n}",["149","150"],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Data.tsx",["151","152","153","154","155","156","157","158","159"],"import React, { Component, useState } from 'react'\nimport Layout from './Layout'\nimport * as _ from 'lodash'\nimport * as d3 from 'd3'\nimport lunr from 'lunr'\n\n\nexport type Coordinate = {\n  x: number,\n  y: number,\n  index: number\n}\n\nexport const min_dists_arr: string[] = ['0.1', '0.2', '0.5', '0.9']\nexport type ParameterMinDist = '0.1' | '0.2' | '0.5' | '0.9'\nexport type MinDist = {\n  '0.1': Coordinate[] | null,\n  '0.2': Coordinate[] | null,\n  '0.5': Coordinate[] | null,\n  '0.9': Coordinate[] | null,\n  [i: string]: Coordinate[] | null\n}\n\nexport const num_neighbors_arr: string[] = ['2', '5', '10', '50']\nexport type ParameterNumNeighbors = '2' | '5' | '10' | '50'\nexport type NumNeighbors = {\n  '2': MinDist,\n  '5': MinDist,\n  '10': MinDist,\n  '50': MinDist,\n  [i: string]: MinDist\n}\n\n/** used to keep track of changed label */\nexport type DataChanged = {\n  oldLabel: Label\n  newLabel: Label\n} & DataPoint\n\nexport type DataPoint = {\n  publishedAt: string,\n  authorName: string,\n  isReply: number,\n  text: string | null,\n  cleaned: string,\n  i: number\n}\n\nexport type Label = {\n  label_kmedoids: string\n}\n\nexport type ClusterInfo = {\n  /**is the index of the medoid of that data point.\n   * medoid might be null for newly created clusters.\n  */\n  medoid: number | null,\n  /**are the indices of representatives of this cluster */\n  representatives: number[],\n  size: number,\n  quality: number\n}\n\nexport type Cluster = {\n  [cluster: string]: ClusterInfo\n}\n\ntype State = {\n  /** this has actually all coordinates, unlike allCoordinates,\n   * which has a sample for all parameters */\n  allCoordinatesFull: NumNeighbors | null,\n  /** samples to show for coordinate parameters */\n  allCoordinates: Coordinate[] | null,\n  coordinatesParameters: {\n    numNeighborsParameter: ParameterNumNeighbors,\n    minDistParameter: ParameterMinDist,\n  }\n  coordinates_to_show: number, // i.e. all svg circles to show\n  data: DataPoint[] | null,\n  /** data that was moved between clusters */\n  dataChanged: DataChanged[]\n  labels: Label[] | null,\n  searchIndex: lunr.Index | null,\n  /** is an array of cluster names to show on the projection */\n  clustersToShow: string[],\n  clusters: Cluster,\n  /** the coordinate of the comment the user hovers over, or null if not hovering */\n  hoveredCommentCoordinate: Coordinate | null,\n}\n\nexport type PropsFromData = {\n  /** reloads as many coordinates that are shown in Projection as specified in e */\n  reloadCoordinatesWithSize: (e: React.ChangeEvent<HTMLInputElement>) => Promise<void>,\n  setSelectedCoordinates: (numNeighbors: ParameterNumNeighbors, minDist: ParameterMinDist) => void,\n  /**\n   * \n   * @param clusters is an array of labels of the clusters to show\n   */\n  setClustersToShow: (clusters: string[]) => void,\n  /**\n   * changes all occurences of oldLabel to newLabel inside labels and\n   * clustersToShow.\n   * Make sure to handle all lower lying variables, e.g. selectedCluster,\n   * yourself.\n   * @param oldLabels\n   * @param newLabel \n   */\n  renameLabels: (oldLabels: string[], newLabel: string) => void,\n  /** \n   * adds new entry to dataChanged\n   * if entry with same i property already exists, then first remove that.\n   * if oldlabel is the same as newlabel, then remove and don't add\n   * updates clusters state too\n   */\n  pushToDataChanged: (newDataChange: DataChanged) => void,\n  /**\n   * sets hoveredCommentCoordinate to the coordinate associated with\n   * comment_index, or null of comment_index is null\n   */\n  setHoveredCommentCoordinate: (comment_index: number | null) => void,\n  [key: string]: any,\n} & State\n\n\nexport default class Data extends Component<any, State> {\n  random_indices: number[] | null = null\n\n  constructor(props: any) {\n    super(props)\n    this.state = {\n      allCoordinatesFull: null,\n      allCoordinates: null,\n      coordinatesParameters: {\n        numNeighborsParameter: '10',\n        minDistParameter: '0.1'\n      },\n      coordinates_to_show: 400,\n      data: null,\n      labels: null,\n      searchIndex: null,\n      clustersToShow: [],\n      clusters: {},\n      dataChanged: [],\n      hoveredCommentCoordinate: null,\n    }\n    this.reloadCoordinatesWithSize = this.reloadCoordinatesWithSize.bind(this)\n    this.setSelectedCoordinates = this.setSelectedCoordinates.bind(this)\n    this.setClustersToShow = this.setClustersToShow.bind(this)\n    this.renameLabels = this.renameLabels.bind(this)\n    this.pushToDataChanged = this.pushToDataChanged.bind(this)\n    this.setHoveredCommentCoordinate = this.setHoveredCommentCoordinate.bind(this)\n  }\n\n  setHoveredCommentCoordinate(comment_index: number | null) {\n    if (!comment_index) {\n      this.setState({\n        hoveredCommentCoordinate: null\n      })\n      return\n    }\n    if (!this.state.allCoordinatesFull) return\n    const allComments = this.state.allCoordinatesFull[this.state.coordinatesParameters.numNeighborsParameter][this.state.coordinatesParameters.minDistParameter]\n    this.setState({\n      hoveredCommentCoordinate: allComments![comment_index]\n    })\n  }\n\n  pushToDataChanged(newData: DataChanged) {\n    let alreadyExisting = _.find(this.state.dataChanged, ['i', newData.i])\n    let newDataChanged = _.without(this.state.dataChanged, alreadyExisting)\n    if (!(\n      alreadyExisting && alreadyExisting.oldLabel.label_kmedoids == newData.newLabel.label_kmedoids // if users reverts change, skip\n      || !alreadyExisting && newData.oldLabel.label_kmedoids == newData.newLabel.label_kmedoids // if wasnt changed before but has no change either, skip\n    )) newDataChanged.push(newData)\n\n    // if new cluster, set clusters\n    if (!this.state.clusters[newData.newLabel.label_kmedoids]) {\n      let copy = { ...this.state.clusters }\n      copy[newData.newLabel.label_kmedoids] = {\n        medoid: null,\n        representatives: [],\n        size: 1,\n        quality: -1,\n      }\n      this.setState({\n        clusters: copy\n      })\n    }\n\n    this.setState({\n      dataChanged: newDataChanged as DataChanged[]\n    })\n  }\n\n  renameLabels(oldLabels: string[], newLabel: string) {\n    // rename in clusterToShow\n    const newClustersToShow = this.state.clustersToShow.map(\n      (el, i) => oldLabels.includes(el) ? newLabel : el\n    )\n\n    // rename in labels\n    const labels_new = this.state.labels!.map(\n      (label) => {\n        if (oldLabels.includes(label.label_kmedoids)) {\n          return { label_kmedoids: newLabel } as Label\n        }\n        return label\n      }\n    )\n\n    // rename in clusters\n    let clusters_new: Cluster = { ...this.state.clusters }\n    let didMerge = false\n    for (const oldLabel of oldLabels) {\n\n      const isMerging = clusters_new[newLabel]\n      if (isMerging) { // merge if new already exists\n        didMerge = true\n        clusters_new[newLabel] = {\n          medoid: clusters_new[newLabel].medoid,\n          representatives: [...clusters_new[oldLabel].representatives, ...clusters_new[newLabel].representatives],\n          size: clusters_new[oldLabel].size + clusters_new[newLabel].size,\n          quality: -1\n        }\n      } else { // rename else\n        clusters_new[newLabel] = {...this.state.clusters[oldLabel]}\n      }\n      delete clusters_new[oldLabel]\n    }\n\n    // rename in dataChanged\n    let dataChanged_new = this.state.dataChanged.map(el =>\n      (oldLabels.includes(el.newLabel.label_kmedoids))\n        ? { ...el, newLabel: { label_kmedoids: newLabel } }\n        : el\n    )\n\n    this.setState({\n      clustersToShow: newClustersToShow,\n      labels: labels_new,\n      clusters: clusters_new,\n      dataChanged: dataChanged_new\n    }, () => {\n      if (didMerge) this.calc_quality()\n    })\n  }\n\n  updateSelectedCoordinates() {\n    if (!this.state.allCoordinatesFull) {\n      console.log('allCoordinates is null')\n      return []\n    }\n\n    const numNeighbors = this.state.coordinatesParameters.numNeighborsParameter\n    const minDist = this.state.coordinatesParameters.minDistParameter\n\n    const rand_indices = this.getRandomIndices(this.state.labels!, this.state.clustersToShow, this.state.coordinates_to_show)\n    const coordinates = rand_indices.map(i => this.state.allCoordinatesFull![numNeighbors][minDist]![i])\n\n    this.setState({\n      allCoordinates: coordinates\n    })\n  }\n\n  setClustersToShow(clusters: string[]) {\n    this.setState({\n      clustersToShow: clusters\n    }, this.updateSelectedCoordinates)\n  }\n\n  /** unlike getSelectedCoordinates, this returns all coordinates,\n   * not only a sample\n   */\n  _getAllSelectedCoordinates() {\n    if (!this.state.allCoordinatesFull) {\n      console.log('allCoordinatesFull is null')\n      return []\n    }\n    const numNeighbors = this.state.coordinatesParameters.numNeighborsParameter\n    const minDist = this.state.coordinatesParameters.minDistParameter\n    return this.state.allCoordinatesFull[numNeighbors][minDist] || []\n  }\n\n  setSelectedCoordinates(numNeighbors: ParameterNumNeighbors, minDist: ParameterMinDist) {\n    this.setState({\n      coordinatesParameters: {\n        numNeighborsParameter: numNeighbors,\n        minDistParameter: minDist\n      }\n    }, this.updateSelectedCoordinates) // then update svg points\n  }\n\n  /**\n   * scales embeddings to values between [0, 10]\n   * the index key stays untouched.\n   * @param embeddings are the coordinates, has form [{x->val,y->val, index->val},...]\n   * @returns an array of the coordinates of the form [[x, y, index], ...]\n   */\n  scaleEmbeddings(embeddings: Coordinate[]) {\n    let xs = embeddings.map(e => Math.abs(e.x))\n    let ys = embeddings.map(e => Math.abs(e.y))\n    let max_x = _.max(xs) || 0\n    let max_y = _.max(ys) || 0\n    let max = Math.max(max_x, max_y)\n    let scale = d3\n      .scaleLinear()\n      .domain([-max, max])\n      .range([0, 100])\n    let scaled_embeddings = embeddings.map(e => {\n      const coordinate_scaled: Coordinate = {\n        'x': scale(e.x), 'y': scale(e.y), 'index': e.index\n      }\n      return coordinate_scaled\n    }\n    )\n    return scaled_embeddings\n  }\n\n  /**\n   * picks n random elements from arr without duplicates.\n   * \n   * if bigger is longer than 4/5th of arr's length, random indices of the lenght of the whole\n   * list @param arr is  returned as a random picks would take too many tries to find new indices.\n   * \n   * modified from\n   * https://stackoverflow.com/questions/19269545/how-to-get-a-number-of-random-elements-from-an-array\n   * \n   * @param {*} arr the original giving the shape\n   * @param clustersToShow is an array of clusters to pick from\n   * @param {*} n how many to pick from\n   */\n  getRandomIndices(arr: any[], clustersToShow: string[], n: number) {\n    let indices_arr = Array.from(Array(arr.length).keys()) // why so difficult, js?\n\n    indices_arr = indices_arr.filter(i => {\n      if (!this.state.labels) return false\n      return clustersToShow.includes(this.state.labels[i].label_kmedoids)\n    })\n\n    if (n > indices_arr.length * 4 / 5) {\n      return indices_arr\n    }\n\n    var result = new Array(n),\n      len = indices_arr.length,\n      taken = new Array(len);\n    if (n > len)\n      throw new RangeError(\"getRandom: more elements taken than available\");\n    while (n--) {\n      var x = Math.floor(Math.random() * len);\n      result[n] = indices_arr[x in taken ? taken[x] : x];\n      taken[x] = --len in taken ? taken[len] : len;\n    }\n    return result;\n  }\n\n  /**\n   * how many coordinates to pcik form all clusters to show coordinates\n   * @param howMany how many to numbers to pick from all clusters to show\n   */\n  async loadCoordinates(howMany: number) {\n    var all_coordinates_full: NumNeighbors = {\n      '2': { '0.1': null, '0.2': null, '0.5': null, '0.9': null },\n      '5': { '0.1': null, '0.2': null, '0.5': null, '0.9': null },\n      '10': { '0.1': null, '0.2': null, '0.5': null, '0.9': null },\n      '50': { '0.1': null, '0.2': null, '0.5': null, '0.9': null },\n    }\n    for (let num_neighbors of num_neighbors_arr) { // go over all num_neigbor parameters\n      for (let min_dist of min_dists_arr) { // and over all its min_dist variants\n\n        let scaled_coordinates: Coordinate[] = []\n        const fetched = await fetch(`${process.env.PUBLIC_URL}/coordinates/coordinates_supervised.${num_neighbors}.${min_dist}.json`)\n        const coordinates: Coordinate[] = await fetched.json()\n        scaled_coordinates = this.scaleEmbeddings(coordinates)\n        all_coordinates_full[num_neighbors][min_dist] = scaled_coordinates\n      }\n    }\n\n    return this.setState({\n      allCoordinatesFull: all_coordinates_full,\n    }, this.calc_quality) // calc_quality doesnt do anything on first run\n  }\n\n  async reloadCoordinatesWithSize(event: React.ChangeEvent<HTMLInputElement>) {\n    let size = parseInt(event.target.value) || 0\n\n    return this.setState({\n      coordinates_to_show: size\n    }, this.updateSelectedCoordinates)\n  }\n\n  async loadDataAndSearchIndex() {\n    const fetched = await fetch(`${process.env.PUBLIC_URL}/data.json`)\n    let data: DataPoint[] = JSON.parse(await fetched.text())\n    data.forEach((el, i) => {\n      el.i = i\n    })\n    const search_index = lunr(function () {\n      this.field('comment')\n\n      for (let i = 0; i < data.length; i++) {\n        this.add({\n          'comment': data[i].cleaned,\n          'id': `${i}`,\n        })\n      }\n    })\n    this.setState({\n      data: data,\n      searchIndex: search_index\n    })\n  }\n\n  async loadLabels() {\n    const fetched = await fetch(`${process.env.PUBLIC_URL}/labels.json`)\n    let labels: Label[] = JSON.parse(await fetched.text())\n    labels = labels.map(el => {\n      return {\n        label_kmedoids: `${el.label_kmedoids}`\n      }\n    })\n\n    this.setState({\n      labels: labels,\n    })\n  }\n\n  /** sets the quality for each cluster.\n   */\n  calc_quality() {\n    // using average of squared euclidean distances\n    const clusters = { ...this.state.clusters }\n    for (let label in clusters) {\n      if (!clusters[label].medoid) return // shouldnt happen\n      const coordinates = this._getAllSelectedCoordinates()\n      let medoid_pos = coordinates[clusters[label].medoid!]\n      let distances = coordinates.map(\n        (coord) => {\n          if (this.state.labels?.[coord.index].label_kmedoids != label) return\n          // is of same cluster:\n          let sqrd_eucl_dist = Math.sqrt(Math.pow(coord.x - medoid_pos.x, 2) + Math.pow(coord.y - medoid_pos.y, 2))\n          return sqrd_eucl_dist\n        }\n      )\n      clusters[label].quality = _.mean(distances)\n    }\n\n    this.setState({\n      clusters: clusters\n    })\n  }\n\n  /** loads cluster representatives from disk and creates clusters state */\n  async loadClusters() {\n    const fetchedReprs = await fetch(`${process.env.PUBLIC_URL}/cluster-representatives.json`)\n    const representatives: { [key: string]: number[] } = JSON.parse(await fetchedReprs.text())\n\n    const fetchedMedoids = await fetch(`${process.env.PUBLIC_URL}/medoids.json`)\n    const medoids: { medoids_indices: number }[] = JSON.parse(await fetchedMedoids.text())\n\n    let clusters: Cluster = {}\n\n    for (let orig_label in representatives) {\n      clusters[orig_label] = {\n        medoid: medoids[parseInt(orig_label)].medoids_indices,\n        representatives: representatives[orig_label],\n        size: 0,\n        quality: 0\n      }\n    }\n\n    for (let label of this.state.labels!) {\n      clusters[label.label_kmedoids].size += 1\n    }\n\n    this.setState({\n      clusters: clusters\n    }, () => this.calc_quality())\n  }\n\n\n  async componentDidMount() {\n    await Promise.all([\n      this.loadCoordinates(this.state.coordinates_to_show), // embeddings\n      this.loadDataAndSearchIndex(),\n      this.loadLabels(),\n    ])\n    await this.setSelectedCoordinates(this.state.coordinatesParameters.numNeighborsParameter, this.state.coordinatesParameters.minDistParameter)\n    await this.loadClusters()\n  }\n\n  render() {\n    const props: PropsFromData = {\n      ...this.state,\n      reloadCoordinatesWithSize: this.reloadCoordinatesWithSize,\n      setSelectedCoordinates: this.setSelectedCoordinates,\n      setClustersToShow: this.setClustersToShow,\n      renameLabels: this.renameLabels,\n      pushToDataChanged: this.pushToDataChanged,\n      setHoveredCommentCoordinate: this.setHoveredCommentCoordinate,\n    }\n    return this.state.allCoordinates && this.state.data && this.state.labels ? (\n      <Layout {...props} />\n    ) : (\n        <div style={{ padding: '1rem' }}>Loading data...</div>\n      )\n  }\n}","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Layout.tsx",["160","161","162","163","164","165","166","167"],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/Sidebar.tsx",["168","169","170","171","172","173","174"],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterOverview/ClusterOverview.tsx",["175"],"import React from 'react';\nimport ClusterSnippet from './ClusterSnippet'\nimport ClusterTable from './ClusterTable';\nimport { PropsForSidebar } from '../../Sidebar';\n\n\nexport type PropsForClusterOverview = PropsForSidebar\n\n/**\n * \n * @param comments is the subset of the data which has label @param label\n * @param label is the label of said comments\n */\nexport default function ClusterOverview(props:PropsForClusterOverview) {\n    const labelSet = new Set()\n    for (let element of props.labels!) {\n        labelSet.add(element.label_kmedoids)\n    }\n\n    return (\n        <ClusterTable {...props}/>\n    )\n}","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterOverview/ClusterTable.tsx",["176","177","178","179","180","181","182","183"],"import React, { MouseEventHandler, useEffect, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { lighten, makeStyles } from '@material-ui/core/styles';\nimport Table from '@material-ui/core/Table';\nimport TableBody from '@material-ui/core/TableBody';\nimport TableCell from '@material-ui/core/TableCell';\nimport TableContainer from '@material-ui/core/TableContainer';\nimport TableHead from '@material-ui/core/TableHead';\nimport TablePagination from '@material-ui/core/TablePagination';\nimport TableRow from '@material-ui/core/TableRow';\nimport TableSortLabel from '@material-ui/core/TableSortLabel';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport Typography from '@material-ui/core/Typography';\nimport Paper from '@material-ui/core/Paper';\nimport Checkbox from '@material-ui/core/Checkbox';\nimport { Cluster, DataChanged, Label, PropsFromData } from '../../Data';\nimport { PropsForSidebar } from '../../Sidebar';\n\ntype Row = {\n    label: string,\n    size: number,\n    metric: string\n}\n\ntype OrderBy = 'label' | 'size' | 'metric'\n\ntype ClusterInfoDict = {\n    [label: string]: {\n        'size': number,\n        'metric': number,\n    }\n}\n\nvar labelsAndData = {}\nvar rows: Row[] = []\n\nfunction descendingComparator(a: Row, b: Row, orderBy: OrderBy) {\n    if (b[orderBy] < a[orderBy]) {\n        return -1;\n    }\n    if (b[orderBy] > a[orderBy]) {\n        return 1;\n    }\n    return 0;\n}\n\nfunction getComparator(order: string, orderBy: OrderBy) {\n    return order === 'desc'\n        ? (a: Row, b: Row) => descendingComparator(a, b, orderBy)\n        : (a: Row, b: Row) => -descendingComparator(a, b, orderBy);\n}\n\nfunction stableSort(array: Row[], comparator: (a: Row, b: Row) => number) {\n    const stabilizedThis = array.map((el, index) => [el, index]);\n    stabilizedThis.sort((a: any, b: any) => {\n        const order = comparator(a[0], b[0]);\n        if (order !== 0) return order;\n        return a[1] - b[1];\n    });\n    return stabilizedThis.map((el) => el[0] as Row);\n}\n\n\nfunction EnhancedTableHead(props: any) {\n    const { classes, onSelectAllClick, order, orderBy, numSelected, rowCount, onRequestSort } = props;\n    const createSortHandler = (property: string) => (event: any) => {\n        onRequestSort(event, property);\n    };\n\n    const headCells = [\n        { id: 'label', numeric: false, disablePadding: true, label: 'Cluster Name' },\n        { id: 'size', numeric: true, disablePadding: false, label: 'Size' },\n        { id: 'metric', numeric: true, disablePadding: false, label: 'Density' },\n    ];\n\n    return (\n        <TableHead>\n            <TableRow>\n                <TableCell padding=\"checkbox\">\n                    <Checkbox\n                        indeterminate={numSelected > 0 && numSelected < rowCount}\n                        checked={rowCount > 0 && numSelected === rowCount}\n                        onChange={onSelectAllClick}\n                        inputProps={{ 'aria-label': 'show all clusters' }}\n                    />\n                </TableCell>\n                {headCells.map((headCell) => (\n                    <TableCell\n                        key={headCell.id}\n                        align={headCell.numeric ? 'right' : 'left'}\n                        padding={headCell.disablePadding ? 'none' : 'default'}\n                        sortDirection={orderBy === headCell.id ? order : false}\n                    >\n                        <TableSortLabel\n                            active={orderBy === headCell.id}\n                            direction={orderBy === headCell.id ? order : 'asc'}\n                            onClick={createSortHandler(headCell.id)}\n                        >\n                            <Typography style={{ fontWeight: 600 }}>{headCell.label}</Typography>\n                            {orderBy === headCell.id ? (\n                                <span className={classes.visuallyHidden}>\n                                    {order === 'desc' ? 'sorted descending' : 'sorted ascending'}\n                                </span>\n                            ) : null}\n                        </TableSortLabel>\n                    </TableCell>\n                ))}\n            </TableRow>\n        </TableHead>\n    );\n}\n\nEnhancedTableHead.propTypes = {\n    classes: PropTypes.object.isRequired,\n    numSelected: PropTypes.number.isRequired,\n    onRequestSort: PropTypes.func.isRequired,\n    onSelectAllClick: PropTypes.func.isRequired,\n    order: PropTypes.oneOf(['asc', 'desc']).isRequired,\n    orderBy: PropTypes.string.isRequired,\n    rowCount: PropTypes.number.isRequired,\n};\n\nfunction EnhancedTableToolbar(props: any) {\n    return (\n        <Toolbar>\n            <Typography variant=\"h4\" id=\"tableTitle\" style={{ padding: '40px 0' }}>Overview Clusters</Typography>\n        </Toolbar>\n    );\n}\n\nEnhancedTableToolbar.propTypes = {\n    numSelected: PropTypes.number.isRequired,\n};\n\nconst useStyles = makeStyles((theme) => ({\n    paper: {\n        color: 'white',\n        backgroundColor: 'unset',\n        width: '100%',\n        marginBottom: theme.spacing(2),\n    },\n    table: {\n        color: 'white',\n    },\n    visuallyHidden: {\n        border: 0,\n        clip: 'rect(0 0 0 0)',\n        height: 1,\n        margin: -1,\n        overflow: 'hidden',\n        padding: 0,\n        position: 'absolute',\n        top: 20,\n        width: 1,\n    },\n}));\n\nconst useTablePaginationStyles = makeStyles((theme) => ({\n    spacer: {\n        flex: '1'\n    },\n    actions: {\n        marginLeft: '0',\n        marginRight: '0'\n    },\n    input: {\n        flex: '1 3 100%',\n        marginLeft: '0',\n        marginRight: '0'\n    },\n    caption: {\n        flex: '1 1 100%'\n    },\n\n}))\n\nconst useTableRowStyles = makeStyles((theme) => ({\n    selected: {\n        backgroundColor: 'rgba(63, 81, 181, 0.30) !important'\n    },\n    hover: {\n        '&:hover': {\n            backgroundColor: 'rgba(63, 81, 181, 0.1) !important'\n        }\n    }\n}))\n\n\nfunction clustersToRows(clusters: Cluster) {\n    let rows = []\n    for (let label in clusters) {\n        rows.push({ 'label': label, 'size': clusters[label].size, 'metric': clusters[label].quality.toFixed(2) })\n    }\n    return rows\n}\n\ntype PropsClusterTable = PropsForSidebar\nexport default function ClusterTable({\n    labels,\n    data,\n    dataChanged,\n    clustersToShow,\n    setClustersToShow,\n    selectCluster,\n    ...other }: PropsClusterTable) {\n\n    const classes = useStyles();\n    const classesTableRow = useTableRowStyles()\n    const classesTablePagination = useTablePaginationStyles()\n    const [order, setOrder] = useState('desc');\n    const [orderBy, setOrderBy] = useState('size' as OrderBy);\n    const [page, setPage] = useState(0);\n    const [rowsPerPage, setRowsPerPage] = useState(15);\n\n    rows = clustersToRows(other.clusters)\n\n    const handleRequestSort = (event: any, property: OrderBy) => {\n        const isAsc = orderBy === property && order === 'asc';\n        setOrder(isAsc ? 'desc' : 'asc');\n        setOrderBy(property);\n    };\n\n    const handleSelectAllClick = (event: any) => {\n        if (event.target.checked) {\n            const newSelecteds = rows.map((n) => n.label);\n            setClustersToShow(newSelecteds);\n            return;\n        }\n        setClustersToShow([]);\n    };\n\n    const handleCheckboxClick = (event: any, name: string) => {\n        const selectedIndex = clustersToShow.indexOf(name);\n        let newSelected: string[] = [];\n\n        if (selectedIndex === -1) { // wasn't clicked before\n            newSelected = newSelected.concat(clustersToShow, name);\n        } else if (selectedIndex === 0) {\n            newSelected = newSelected.concat(clustersToShow.slice(1));\n        } else if (selectedIndex === clustersToShow.length - 1) {\n            newSelected = newSelected.concat(clustersToShow.slice(0, -1));\n        } else if (selectedIndex > 0) {\n            newSelected = newSelected.concat(\n                clustersToShow.slice(0, selectedIndex),\n                clustersToShow.slice(selectedIndex + 1),\n            );\n        }\n\n        setClustersToShow(newSelected);\n    }\n\n    const handleRowClick = (event: any, name: string) => {\n        if (event.target.nodeName === \"INPUT\") return // skip if over checkbox\n        selectCluster(name)\n        // click checkbox if not cliked yet\n        const selectedIndex = clustersToShow.indexOf(name);\n        let newSelected: string[] = [];\n\n        if (selectedIndex === -1) { // wasn't clicked before\n            newSelected = newSelected.concat(clustersToShow, name);\n            setClustersToShow(newSelected);\n        }\n    };\n\n    const handleChangePage = (event: any, newPage: number) => {\n        setPage(newPage);\n    };\n\n    const handleChangeRowsPerPage = (event: any) => {\n        setRowsPerPage(parseInt(event.target.value, 10));\n        setPage(0);\n    };\n\n    const isSelected = (name: string) => clustersToShow.indexOf(name) !== -1;\n\n    const emptyRows = rowsPerPage - Math.min(rowsPerPage, rows.length - page * rowsPerPage);\n\n    const rowsSorted = stableSort(rows, getComparator(order, orderBy))\n\n    useEffect(() => {\n        // select and show first four elements\n        setClustersToShow(\n            rowsSorted.slice(0, 4).map(row => row.label)\n        )\n    }, []) // only run on mount/unmount of component\n\n    useEffect(() => {\n        rows = clustersToRows(other.clusters)\n    }, [other.clusters]) // if clusters change, update rows\n\n    return (\n        <div>\n            <Paper className={classes.paper}>\n                <EnhancedTableToolbar numSelected={clustersToShow.length} />\n                <TableContainer>\n                    <Table\n                        style={{ width: '100%', minWidth: 'auto' }}\n                        className={classes.table}\n                        aria-labelledby=\"tableTitle\"\n                        size='medium'\n                        aria-label=\"cluster table\"\n                    >\n                        <EnhancedTableHead\n                            classes={classes}\n                            numSelected={clustersToShow.length}\n                            order={order}\n                            orderBy={orderBy}\n                            onSelectAllClick={handleSelectAllClick}\n                            onRequestSort={handleRequestSort}\n                            rowCount={rows.length}\n                        />\n                        <TableBody>\n                            {rowsSorted\n                                .slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage)\n                                .map((row: Row, index: number) => {\n                                    const isItemSelected = isSelected(row.label);\n                                    const labelId = `enhanced-table-checkbox-${index}`;\n                                    return (\n                                        <TableRow\n                                            hover\n                                            onClick={(event: any) => handleRowClick(event, row.label)}\n                                            role=\"checkbox\"\n                                            aria-checked={isItemSelected}\n                                            tabIndex={-1}\n                                            key={row.label}\n                                            selected={isItemSelected}\n                                            classes={classesTableRow}\n                                        >\n                                            <TableCell padding=\"checkbox\">\n                                                <Checkbox\n                                                    color='secondary'\n                                                    checked={isItemSelected}\n                                                    inputProps={{ 'aria-labelledby': labelId }}\n                                                    onClick={(event) => handleCheckboxClick(event, row.label)}\n                                                />\n                                            </TableCell>\n                                            <TableCell component=\"th\" id={labelId} scope=\"row\" padding=\"none\" width={'70%'}>\n                                                {row.label}\n                                            </TableCell>\n                                            <TableCell width={'10%'} align=\"right\">{row.size}</TableCell>\n                                            <TableCell width={'10%'} align=\"right\">{row.metric}</TableCell>\n                                        </TableRow>\n                                    );\n                                })}\n                            {emptyRows > 0 && (\n                                <TableRow style={{ height: 53 * emptyRows }}>\n                                    <TableCell colSpan={4} />\n                                </TableRow>\n                            )}\n                        </TableBody>\n                    </Table>\n                </TableContainer>\n                <TablePagination\n                    classes={classesTablePagination}\n                    rowsPerPageOptions={[10,20,45]}\n                    component=\"div\"\n                    count={rows.length}\n                    rowsPerPage={rowsPerPage}\n                    page={page}\n                    onChangePage={handleChangePage}\n                    onChangeRowsPerPage={handleChangeRowsPerPage}\n                />\n            </Paper>\n        </div>\n    );\n}\n","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/ClusterMenu.tsx",["184","185"],"import AppBar from '@material-ui/core/AppBar';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport IconButton from '@material-ui/core/IconButton';\nimport { ArrowBack } from '@material-ui/icons';\nimport { createStyles, makeStyles, TextField, Theme } from '@material-ui/core';\nimport { PropsForSidebar } from '../../Sidebar'\nimport React from 'react';\n\n\nconst useStyles = makeStyles((theme: Theme) => ({\n    root: {\n        flexGrow: 1,\n    },\n    menuButton: {\n        marginRight: theme.spacing(2),\n    },\n    title: {\n        flexGrow: 1,\n    }\n})\n);\n\ntype PropsClusterMenu = {\n    labelLocal: string,\n    setLabelLocal: (newLabel: string) => void\n} & PropsForSidebar\n\nexport default function ClusterMenu(props: PropsClusterMenu) {\n    const classes = useStyles()\n\n    const handleArrowBack = () => {\n        if (props.selectedCluster! != props.labelLocal) props.renameLabels([props.selectedCluster!], (props.labelLocal || \"N/A\"))\n        props.selectCluster(null)\n        props.setLabelLocal(\"\")\n        props.setSelectedDatum(null)\n    }\n\n    return (\n        <AppBar position='relative' color='transparent'>\n            <Toolbar>\n                <IconButton edge=\"start\" className={classes.menuButton}\n                    color=\"inherit\" aria-label=\"menu\" onClick={handleArrowBack}>\n                    <ArrowBack />\n                </IconButton>\n                <TextField\n                    inputProps={{ style: { fontSize: '1.5em', fontWeight: 600, padding: '8px'}}}\n                    variant=\"filled\"\n                    value={props.labelLocal}\n                    onChange={(e: any) => props.setLabelLocal(e.target.value)}\n                />\n            </Toolbar>\n        </AppBar>\n    )\n}","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/MetaInfo.tsx",["186","187","188","189"],"import { PropsForSidebar } from '../../Sidebar'\nimport { Cluster, ClusterInfo, DataPoint } from '../../Data'\nimport React from 'react'\nimport TextField from '@material-ui/core/TextField'\nimport NeoMorphCard from './NeoMorphCard'\nimport { makeStyles } from '@material-ui/core/styles'\nimport { Card, CardContent } from '@material-ui/core'\n\n\ntype PropsMetaInfos = {\n    selectedClusterInfo: ClusterInfo\n} & PropsForSidebar\n\nconst useStyles = makeStyles((theme) => ({\n    styleContainer: {\n        display: 'block',\n        marginLeft: theme.spacing(2),\n        marginRight: theme.spacing(2),\n        marginBottom: theme.spacing(2),\n    }\n}))\n\nexport default function MetaInfo(props: PropsMetaInfos) {\n    const classes = useStyles()\n    const { selectedClusterInfo } = props\n\n    const prct = ((selectedClusterInfo?.size || 0) * 100 / (props.data?.length || 1)).toFixed(2)\n    return (\n        <Card className={classes.styleContainer}>\n            <CardContent>\n                <p><b>Size:</b> {selectedClusterInfo?.size || 0} of {props.data?.length} comments in total</p>\n                <p><b>Size (in %):</b> {prct} %</p>\n                <p><b>Density</b> (lower is better): {selectedClusterInfo?.quality?.toFixed(3) || 0}</p>\n            </CardContent>\n        </Card>\n    )\n}","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/NeoMorphCard.tsx",["190","191","192"],"import { PropsForSidebar } from '../../Sidebar'\nimport { createUseStyles } from 'react-jss'\nimport { DataPoint } from '../../Data'\nimport React from 'react'\nimport TextField from '@material-ui/core/TextField'\n\nconst useStyles = createUseStyles(\n    {\n        card: {\n            display: 'block',\n            margin: '32px 24px',\n            padding: '4px 16px',\n            position: 'relative',\n        },\n        neomorphism: {\n            borderRadius: '15px',\n            background: 'linear-gradient(145deg, #373737, #2e2e2e)',\n            boxShadow: '5px 5px 12px #181818, -5px -5px 12px #4e4e4e'\n        },\n    })\n\ntype NeoMorphProps = {\n    children: React.ReactNode\n}\n\nexport default function NeoMorphCard(props: NeoMorphProps) {\n    const classes = useStyles()\n\n    return (\n        <div className={`${classes.neomorphism} ${classes.card}`}>\n            {props.children}\n        </div>\n    )\n}",["193","194"],"/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterMerger.tsx",["195","196","197"],"import React, { useEffect, useState } from \"react\";\nimport { Button, makeStyles, TextField, Toolbar, Typography } from \"@material-ui/core\";\nimport Autocomplete from '@material-ui/lab/Autocomplete';\nimport { PropsForSidebar } from \"../Sidebar\";\n\nconst useStyles = makeStyles((theme) => ({\n    horizontalContainer: {\n        paddingRight: theme.spacing(3),\n        paddingLeft: theme.spacing(3),\n        paddingTop: '1em',\n        paddingBottom: '1em',\n        width: '100%',\n        height: 'auto'\n    },\n    flexAlignChildren: {\n        display: 'flex',\n        flexDirection: 'row',\n        justifyContent: 'space-evenly'\n    },\n    rightAlign: {\n        display: 'block',\n        marginLeft: 'auto',\n        marginRight: '0'\n    }\n}));\n\nexport default function ClusterMerger(props: PropsForSidebar) {\n    const classes = useStyles()\n    const [newClusterName, setName] = useState('New Cluster Name')\n    const [firstLabel, setFirstLabel] = useState<string | null>(null)\n    const [secondLabel, setSecondLabel] = useState<string | null>(null)\n\n    const allClusters = Array.from(new Set(props.labels?.map(label => label.label_kmedoids)))\n\n    const merge = () => {\n        if (!firstLabel || !secondLabel) return\n        props.renameLabel(firstLabel, newClusterName, () => props.renameLabel(secondLabel, newClusterName))\n        setFirstLabel(null)\n        setSecondLabel(null)\n    }\n\n    const groupByVisibleClusters = (option: string) =>\n        (props.clustersToShow?.includes(option))\n            ? \"Visible Clusters\"\n            : \"Other Clusters\"\n\n    /** comparator to sort array by its visibility in the projection */\n    const compareByVisibility = (a: string, b: string) => {\n        const aGroup = groupByVisibleClusters(a)\n        const bGroup = groupByVisibleClusters(b)\n        if (aGroup < bGroup) return 1\n        else if (aGroup === bGroup) return 0\n        else return -1 //(aGroup > bGroup)\n    }\n\n    return (\n        <>\n            <Toolbar>\n                <Typography variant=\"h6\">Merge two Clusters</Typography>\n            </Toolbar>\n            <div className={`${classes.flexAlignChildren} ${classes.horizontalContainer}`}>\n                <Autocomplete\n                    style={{ flex: '3' }}\n                    options={allClusters.filter(cluster => cluster != secondLabel).sort(compareByVisibility)}\n                    groupBy={groupByVisibleClusters}\n                    renderInput={(params: any) => <TextField {...params} label=\"First\" variant=\"outlined\" />}\n                    onChange={(e, value) => setFirstLabel(value!)}\n                    value={firstLabel}\n                />\n                <p style={{ display: 'inline', flex: '1', textAlign: 'center' }}>+</p>\n                <Autocomplete\n                    style={{ flex: '3' }}\n                    options={allClusters.filter(cluster => cluster != firstLabel).sort(compareByVisibility)}\n                    groupBy={groupByVisibleClusters}\n                    renderInput={(params: any) => <TextField {...params} label=\"Second\" variant=\"outlined\" />}\n                    onChange={(e, value) => setSecondLabel(value!)}\n                    value={secondLabel}\n                />\n            </div>\n            <div className={`${classes.flexAlignChildren} ${classes.horizontalContainer}`}>\n                <p style={{ display: 'inline', flex: '1', textAlign: 'center' }}>=</p>\n                <TextField\n                    style={{ flex: '3' }}\n                    variant='outlined'\n                    value={newClusterName}\n                    onChange={(e) => setName(e.target.value)}\n                />\n            </div>\n            <div className={classes.horizontalContainer}>\n                <Button\n                    variant=\"contained\"\n                    color=\"primary\"\n                    className={classes.rightAlign}\n                    onClick={merge}\n                    disabled={!(firstLabel && secondLabel)}\n                >Merge</Button>\n            </div>\n        </>\n    )\n}","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/ProjectionElements/Projection.tsx",["198","199","200","201","202","203","204","205"],"import React, { Component } from 'react'\nimport * as d3 from 'd3'\nimport { Coordinate, PropsFromData } from '../Data'\nimport { ZoomBehavior } from 'd3'\nimport _, { join } from 'lodash'\nimport { LensTwoTone } from '@material-ui/icons'\n\n\nexport type PropsForProjection = {\n  width: number,\n  height: number,\n  sidebar_ctx: number,\n  selectedCluster: string | null,\n  selectCluster: (newLabel: string | null) => void,\n  setSelectedDatum: (newDatumIndex: number) => void,\n  selected_datum: number | null,\n  searchResultIndices: object & {\n    [key: string]: any | null\n  }\n} & PropsFromData\n\n\nclass Projection extends Component<PropsForProjection, {}> {\n  ref: SVGSVGElement | null = null\n  svg: d3.Selection<SVGSVGElement, any, null, undefined> | null = null\n  scaleTransform: any = null\n\n  constructor(props: PropsForProjection) {\n    super(props)\n    this.state = {}\n  }\n\n  /**\n   * only show given coordinates that are in clustersToShow\n   * @param coords \n   * @param clustersToShow \n   */\n  getIntersectionCoordinatesClustersToShow(coords: Coordinate[], clustersToShow: string[]) {\n    return coords.filter(\n      (coord: Coordinate) => {\n        let labelOfCoord = this.props.labels![coord.index].label_kmedoids\n        if (clustersToShow.includes(`${labelOfCoord}`)) return true\n        return false\n      }\n    ) as Coordinate[]\n  }\n\n  /** \n   * draws scatter plot\n   */\n  drawScatterPlot() {\n    if (!this.ref) return\n\n    const { width, height, setSelectedDatum, allCoordinates,\n      clustersToShow, selectCluster, labels } = this.props\n    this.svg = d3.select(this.ref)\n\n\n    const coordsToShow = this.getIntersectionCoordinatesClustersToShow(allCoordinates!, clustersToShow)\n    if (coordsToShow.length === 0) return this.svg.selectAll('circle').remove()\n\n    const circles = this.svg.selectAll(\"circle\")\n      .data(coordsToShow)\n      .join(\"circle\")\n      .attr('id', d => d.index)\n      .attr(\"transform\", d => `translate(${d.x}, ${d.y})`)\n      .attr(\"fill\", 'white')\n      .attr(\"r\", 3)\n\n    // this click event causes the react lifecycle method componentDidUpdate\n    // to be called. There, we'll update the colors. (the props in this\n    // function body aren't up to date at that point)\n    circles.on(\"click\", event => {\n      let selected_datum_i = parseInt(event.target.id)\n      setSelectedDatum(selected_datum_i)\n      selectCluster(labels![selected_datum_i].label_kmedoids)\n    })\n\n    // zoom behavior\n    const zoomBehavior = this.getZoomBehavior(circles)\n    this.svg.call(zoomBehavior)\n\n    // start with scaled up init view if first time, else take previours scale state \n    this.svg.call(zoomBehavior.transform, this.scaleTransform || this.getInitScale(width, height))\n  }\n\n  /** \n   * returns function which applies a transformation after each zoom\n   * event (that is, dragging around + zooming).\n   * \n   * @param selection is the selection of nodes which should be transformed\n   * @returns a zoomBehavior function, to be called on the node on which this behavior\n   * should be bound to.\n   */\n  getZoomBehavior(selection: d3.Selection<any | null, Coordinate, any | null, any | null>): ZoomBehavior<any, any> {\n    return d3.zoom().on(\"zoom\", (event) => {\n      this.scaleTransform = event.transform\n      selection.attr(\"transform\", (d: Coordinate) => {\n        let coordinateAsArray = [d.x, d.y]\n        return `translate(${event.transform.apply(coordinateAsArray)})`\n      })\n    })\n  }\n\n  /** \n   * @param {int} width the width of the surrounding svg container\n   * @param {int} height the height of the surrounding svg container\n   * @returns a zoom behavior function with a scale factor that scales\n   * the data to width and height\n   * \n   * NOTE: assumes that the scale defined in {Data.js} is [0,100]\n   */\n  getInitScale(width: number, height: number) {\n    const scaleFactor = Math.min(width / 100, height / 100)\n    return d3.zoomIdentity.scale(scaleFactor)\n  }\n\n  componentDidMount() {\n    this.drawScatterPlot()\n  }\n\n  /**\n   * accesses the svg node associated with this class and updates\n   * all points so that the clicked point and the points belonging\n   * to its cluster have distinct colors\n   */\n  updateColorPoints() {\n    const { selected_datum, labels, allCoordinates, clustersToShow } = this.props\n    if (!this.svg || !labels) return\n\n    const coordsToShow = this.getIntersectionCoordinatesClustersToShow(allCoordinates!, clustersToShow)\n    if (coordsToShow.length === 0) return this.svg.selectAll('circle').remove()\n\n\n    this.svg.selectAll('circle')\n      .data(coordsToShow)\n      .attr('fill', d => {\n        if (d.index == selected_datum) return 'cyan'\n        if (this.props.selectedCluster == labels[d.index].label_kmedoids) return 'green'\n        return 'white'\n      })\n  }\n\n  highlightSearchResults() {\n    if (!this.svg) return\n    const { selected_datum, labels, labelChoice, allCoordinates, searchResultIndices, clustersToShow } = this.props\n    const coordsToShow = this.getIntersectionCoordinatesClustersToShow(allCoordinates!, clustersToShow)\n    if (coordsToShow.length === 0) return this.svg.selectAll('circle').remove()\n\n    this.svg.selectAll('circle')\n      .data(coordsToShow)\n      .attr('fill', d => {\n        if (searchResultIndices[d.index]) return 'green'\n        return 'white'\n      })\n  }\n\n  showHoveredComment() {\n    const { selected_datum, labels, allCoordinates, clustersToShow, hoveredCommentCoordinate } = this.props\n    if (!this.svg || !labels) return\n\n    var coordsToShow = this.getIntersectionCoordinatesClustersToShow(allCoordinates!, clustersToShow)\n    if (coordsToShow.length === 0) return this.svg.selectAll('circle').remove()\n\n    this.svg.selectAll('circle')\n      .data(hoveredCommentCoordinate ? [...coordsToShow, hoveredCommentCoordinate] : coordsToShow, (d: any) => d.index)\n      .join(\n        enter => enter.append('circle')\n          .attr('fill', 'cyan')\n          .attr('r', '5')\n          .attr(\"transform\", d => `translate(${this.scaleTransform.k * d.x + this.scaleTransform.x}, ${this.scaleTransform.k * d.y + this.scaleTransform.y})`)\n      )\n  }\n\n  hasSelectedDatumChanged(prevProps: PropsForProjection) {\n    return prevProps.selected_datum !== this.props.selected_datum\n  }\n\n  haveCoordinatesChanged(prevProps: PropsForProjection) {\n    return !_.isEqual(_.sortBy(prevProps.allCoordinates), _.sortBy(this.props.allCoordinates))\n  }\n\n  haveSearchResultsChanged(prevProps: PropsForProjection) {\n    return prevProps.searchResultIndices !== this.props.searchResultIndices\n  }\n\n  haveClustersToShowChanged(prevProps: PropsForProjection) {\n    return !_.isEqual(_.sortBy(prevProps.clustersToShow), _.sortBy(this.props.clustersToShow))\n  }\n\n  hasSelectedClusterChanged(prevProps: PropsForProjection) {\n    return prevProps.selectedCluster !== this.props.selectedCluster\n  }\n\n  hasHoveredCommentCoordinateChanged(prevProps: PropsForProjection) {\n    return prevProps.hoveredCommentCoordinate?.index !== this.props.hoveredCommentCoordinate?.index\n  }\n\n  componentDidUpdate(prevProps: PropsForProjection, prevState: {}) {\n    if (this.haveCoordinatesChanged(prevProps) || this.haveClustersToShowChanged(prevProps)) {\n      this.drawScatterPlot()\n      this.updateColorPoints()\n      return\n    }\n    if (this.hasSelectedClusterChanged(prevProps) || this.hasSelectedDatumChanged(prevProps))\n      return this.updateColorPoints()\n    if (this.haveSearchResultsChanged(prevProps)) return this.highlightSearchResults()\n    if (this.hasHoveredCommentCoordinateChanged(prevProps)) return this.showHoveredComment()\n  }\n\n  render() {\n    const { width, height } = this.props\n    return (\n      <svg ref={(ref) => this.ref = ref} width={width} height={height} overflow=\"hidden\"></svg>\n    )\n  }\n}\n\nexport default Projection\n","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/ProjectionElements/ProjectionParameters.tsx",["206","207"],"import React, { useState } from \"react\"\nimport { CircularProgress, makeStyles, Theme, Typography } from '@material-ui/core'\nimport SlidersParamter from \"./Sliders\"\nimport { PropsFromData } from \"../Data\"\nimport { truncate } from \"lodash\"\nimport { PropsForProjection } from \"./Projection\"\n\n\nconst useStyles = makeStyles<Theme, { width: number, isMouseOver: boolean }>(theme => ({\n    absoluteContainer: {\n        position: 'absolute',\n        left: theme.spacing(3),\n        bottom: theme.spacing(2),\n        padding: theme.spacing(2),\n        width: props => (props.width < 1300) ? '19vw' : '14vw',\n        opacity: props => props.isMouseOver ? 1.0 : 0.2, // transparent until on mouse over\n        transition: 'opacity 0.1s'\n    },\n    oneLineFlex: {\n        display: 'flex',\n        alignItems: 'center'\n    }\n}))\n\nexport default function ProjectionParameters(props: PropsForProjection) {\n    const [isMouseOver, setIsMouseOver] = useState(false)\n    const [isReloadingCoordinates, setIsReloadingCoordinates] = useState(false)\n    const [coordinatesToLoad, setCoordinatesToLoad] = useState(props.coordinates_to_show)\n    const classes = useStyles({ width: props.width, isMouseOver: isMouseOver })\n\n    return (\n        <div className={classes.absoluteContainer}\n            onMouseEnter={() => setIsMouseOver(true)}\n            onMouseLeave={() => setIsMouseOver(false)}>\n            <SlidersParamter {...props} />\n            <div className={classes.oneLineFlex}>\n                <Typography style={{ flex: '5' }}>\n                    Data Points to show:\n                </Typography>\n                <input name=\"numDataPoints\" type=\"text\" pattern=\"[0-9]*\"\n                    style={{ flex: '2 min-content', width: '4em', display: 'inline' }}\n                    value={coordinatesToLoad}\n                    onChange={(e) => {\n                        let size = parseInt(e.target.value) || 0\n                        setCoordinatesToLoad(size)\n                        setIsReloadingCoordinates(true)\n                        props.reloadCoordinatesWithSize(e)\n                            .then(() => {\n                                setIsReloadingCoordinates(false)\n                            })\n                    }}\n                ></input>\n                <CircularProgress\n                    style={{ flex: '1', visibility: isReloadingCoordinates ? 'visible' : 'hidden', marginLeft: '8px' }}\n                    size='1em' color='secondary' />\n            </div>\n        </div>\n    )\n}","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/ProjectionElements/Sliders.tsx",["208","209","210","211","212"],"import React, { Component, useState } from 'react'\nimport { NumNeighbors, PropsFromData, num_neighbors_arr, ParameterNumNeighbors, ParameterMinDist } from '../Data'\nimport { makeStyles } from '@material-ui/core/styles';\nimport Typography from '@material-ui/core/Typography';\nimport Slider from '@material-ui/core/Slider';\nimport Toolbar from '@material-ui/core/Toolbar';\n\nconst useStyles = makeStyles((theme) => ({\n    root: {\n\n    },\n    margin: {\n        height: theme.spacing(3),\n    },\n    slider: {\n        color: theme.palette.text.primary\n    }\n}));\n\nconst marks_num_neighbors = [\n    {\n        value: 2,\n        label: '2',\n    },\n    {\n        value: 5,\n        label: '5',\n    },\n    {\n        value: 10,\n        label: '10',\n    },\n    {\n        value: 50,\n        label: '50',\n    },\n]\n\nconst marks_min_dist = [\n    {\n        value: 1,\n        label: '0.1',\n    },\n    {\n        value: 2,\n        label: '0.2',\n    },\n    {\n        value: 5,\n        label: '0.5',\n    },\n    {\n        value: 9,\n        label: '0.9',\n    },\n]\n\nexport default function SlidersParamter(props: PropsFromData) {\n    const classes = useStyles()\n\n    const numNeighbors = props.coordinatesParameters.numNeighborsParameter\n    const minDist = props.coordinatesParameters.minDistParameter\n\n    return (\n        <>\n            <div className={classes.root}>\n                {/* num neighbors*/}\n                <Typography gutterBottom> \n                    Number of neighbors\n                </Typography>\n                <Slider\n                    getAriaValueText={(val) => `${val}`}\n                    aria-labelledby=\"number of neighbors for underyling umap algorithm\"\n                    step={null}\n                    marks={marks_num_neighbors}\n                    min={2}\n                    max={50}\n                    valueLabelDisplay=\"off\"\n                    value={parseInt(numNeighbors)}\n                    onChange={(event, val) => {\n                        props.setSelectedCoordinates(`${val}` as ParameterNumNeighbors, minDist)\n                    }}\n                    className={classes.slider}\n                />\n                {/* min dist*/}\n                <Typography gutterBottom>\n                    Minimum distance between points\n                </Typography>\n                <Slider\n                    getAriaValueText={(val) => `${val}`}\n                    aria-labelledby=\"number of mininum distances for underyling umap algorithm\"\n                    step={null}\n                    marks={marks_min_dist}\n                    min={1}\n                    max={9}\n                    valueLabelDisplay=\"off\"\n                    value={parseInt(minDist.split('.')[1])} // e.g. '0.1' to 1\n                    onChange={(event, val: number | number[]) => {\n                        props.setSelectedCoordinates(numNeighbors, `0.${val}` as ParameterMinDist)\n                    }}\n                    className={classes.slider}\n                />\n            </div>\n        </>\n    );\n}","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/Comment.tsx",["213"],"import { Button, Card, CardActions, CardContent, makeStyles } from '@material-ui/core'\nimport _ from 'lodash'\nimport React, { useState } from 'react'\nimport { DataPoint } from '../../Data'\nimport { PropsForSidebar } from '../../Sidebar'\nimport ClusterChangeCommentDialog from './ClusterChangeCommentDialog'\n\n\n/**\n * used inside sidebar to display one comment\n * elem is one data point\n */\n\nexport type CommentProps = {\n    dense?: boolean,\n    /** i the the index of the comment in prop data */\n    i: number,\n    /** callback of cluster change for this comment, or null if not changed */\n    onMoveCluster: (newLabel: string | null, i: number) => void\n} & PropsForSidebar\n\nconst useStyles = makeStyles<any, {backgroundColor: string}>((theme) => ({\n    styleContainer: props => ({\n        display: 'block',\n        marginLeft: theme.spacing(2),\n        marginRight: theme.spacing(2),\n        marginBottom: theme.spacing(2),\n        backgroundColor: props.backgroundColor,\n    }),\n    styleMetaInfos: {\n        display: 'block',\n        width: '100%',\n        height: 'auto',\n    },\n    styleUsername: {\n        display: 'inline',\n        fontWeight: 'bold'\n    },\n    styleComment: {\n        marginBottom: '0',\n        marginTop: '8px'\n    },\n    styleDate: {\n        marginLeft: '8px',\n        display: 'inline',\n        color: 'LightGray',\n        fontStyle: 'italic',\n        fontSize: '0.9em'\n    },\n    btnsContainer: {\n        maxHeight: 0,\n        overflow: 'hidden',\n        transitionDelay: '0.2s',\n        transition: 'max-height 0.3s',\n        paddingRight: theme.spacing(3),\n        paddingLeft: theme.spacing(3),\n        width: '100%',\n    },\n    rightAlign: {\n        display: 'block',\n        marginLeft: 'auto',\n        marginRight: '0'\n    },\n}))\n\nexport default function Comment({ dense = false, data, i, onMoveCluster, added=false, removed=false, ...other }: CommentProps) {\n    const backgroundColor: string = added ? '#1d3d17' : removed ? '#3d171b' : \"auto\" \n    const classes = useStyles({backgroundColor: backgroundColor})\n    const { publishedAt, authorName, cleaned } = data![i]\n    const [showClusterChangeDialog, setShowClusterChangeDialog] = useState(false)\n\n    const showPoint = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n        other.setHoveredCommentCoordinate(i)\n    }\n\n    const hidePoint = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n        other.setHoveredCommentCoordinate(null)\n    }\n\n    const dataPoint = _.find(other.dataChanged, ['i', i])\n\n    return (\n        <Card onMouseEnter={showPoint} onMouseLeave={hidePoint} className={classes.styleContainer}>\n            <CardContent>\n                {dataPoint && <p style={{marginLeft: 0}} className={classes.styleDate}>{`from cluster ${dataPoint?.oldLabel.label_kmedoids} to ${dataPoint?.newLabel.label_kmedoids}`}</p>}\n                <div className={classes.styleMetaInfos}>\n                    <p className={classes.styleUsername}>{authorName}</p>\n                    <p className={classes.styleDate}>{publishedAt}</p>\n                </div>\n                <p className={classes.styleComment}>{cleaned}</p>\n            </CardContent>\n            <CardActions>\n                <Button onClick={() => setShowClusterChangeDialog(true)}>Move to other Cluster</Button>\n            </CardActions>\n            <ClusterChangeCommentDialog\n                open={showClusterChangeDialog}\n                onMoveCluster={(clusterSelected) => {\n                    setShowClusterChangeDialog(false)\n                    onMoveCluster(clusterSelected, i)\n                }}\n                i={i}\n                data={data}\n                {...other}\n            />\n        </Card>\n    )\n}","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/SidebarElements/ClusterDetails/ClusterChangeCommentDialog.tsx",["214","215","216","217","218","219","220","221"],"import React from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport Button from '@material-ui/core/Button';\nimport Avatar from '@material-ui/core/Avatar';\nimport List from '@material-ui/core/List';\nimport ListItem from '@material-ui/core/ListItem';\nimport ListItemAvatar from '@material-ui/core/ListItemAvatar';\nimport ListItemText from '@material-ui/core/ListItemText';\nimport DialogTitle from '@material-ui/core/DialogTitle';\nimport Dialog from '@material-ui/core/Dialog';\nimport PersonIcon from '@material-ui/icons/Person';\nimport AddIcon from '@material-ui/icons/Add';\nimport Typography from '@material-ui/core/Typography';\nimport { blue } from '@material-ui/core/colors';\nimport ListSubheader from '@material-ui/core/ListSubheader';\nimport Data, { Label } from '../../Data';\nimport { CommentProps } from './Comment';\nimport _ from 'lodash';\n\nconst emails = ['username@gmail.com', 'user02@gmail.com'];\nconst useStyles = makeStyles({\n    avatar: {\n        backgroundColor: blue[100],\n        color: blue[600],\n    },\n});\n\n\ntype ClusterChangeCommentDialogProps = {\n    open: boolean,\n} & CommentProps\n\n\nexport default function ClusterChangeCommentDialog({\n    open,\n    data,\n    labels,\n    clustersToShow,\n    clusters,\n    onClose,\n    i,\n    selectedCluster,\n    onMoveCluster,\n    ...other\n}: ClusterChangeCommentDialogProps) {\n    const classes = useStyles();\n\n    const remainingClusters = _.without(Object.keys(clusters), ...clustersToShow)\n\n    return (\n        <Dialog onClose={() => onMoveCluster(null, i)} aria-labelledby=\"dialog for changing the cluster of the selected comment\" open={open}>\n            <DialogTitle>Change Cluster</DialogTitle>\n            <List>\n                <ListSubheader component=\"div\" id=\"nested-list-subheader\" disableSticky>Selected Cluster</ListSubheader>\n                <ListItem onClick={() => onMoveCluster(selectedCluster, i)} button key={`clusterpicker-${-1}`}>\n                    <ListItemText primary={selectedCluster} secondary={`size: ${clusters[selectedCluster || \"\"]?.size}    density: ${clusters[selectedCluster || \"\"]?.quality.toFixed(3)}`} />\n                </ListItem>\n                <ListSubheader component=\"div\" id=\"nested-list-subheader\" disableSticky>Visible Clusters</ListSubheader>\n                {\n                    clustersToShow.map((cluster: string) => {\n                        if (cluster === labels![i].label_kmedoids) return\n                        return (\n                            <ListItem onClick={() => onMoveCluster(cluster, i)} button key={`clusterpicker-${cluster}`}>\n                                <ListItemText primary={cluster} secondary={`size: ${clusters[cluster].size}    density: ${clusters[cluster].quality.toFixed(3)}`} />\n                            </ListItem>)\n                    })\n                }\n                <ListSubheader component=\"div\" id=\"nested-list-subheader\" disableSticky>Other Clusters</ListSubheader>\n                {\n                    remainingClusters.map((cluster: string) => (\n                        <ListItem onClick={() => onMoveCluster(cluster, i)} button key={`clusterpicker-${cluster}`}>\n                            <ListItemText primary={cluster} secondary={`size: ${clusters[cluster].size}    density: ${clusters[cluster].quality.toFixed(3)}`} />\n                        </ListItem>)\n                    )\n                }\n                <ListItem onClick={() => onMoveCluster('new', i)} autoFocus button>\n                    <ListItemAvatar>\n                        <Avatar>\n                            <AddIcon />\n                        </Avatar>\n                    </ListItemAvatar>\n                    <ListItemText primary=\"Add to new Cluster\" secondary={'The name of the new cluster is \"new\" by default'}/>\n                </ListItem>\n            </List>\n        </Dialog>\n    )\n}","/Users/danstach/Desktop/Studium/7. Semester/BA/project/umap-explorer/src/DragBar.tsx",["222","223"],{"ruleId":"224","replacedBy":"225"},{"ruleId":"226","replacedBy":"227"},{"ruleId":"228","severity":1,"message":"229","line":7,"column":17,"nodeType":"230","messageId":"231","endLine":7,"endColumn":18},{"ruleId":"224","replacedBy":"232"},{"ruleId":"226","replacedBy":"233"},{"ruleId":"224","replacedBy":"234"},{"ruleId":"226","replacedBy":"235"},{"ruleId":"228","severity":1,"message":"236","line":42,"column":11,"nodeType":"230","messageId":"231","endLine":42,"endColumn":18},{"ruleId":"237","severity":1,"message":"238","line":2,"column":21,"nodeType":"230","messageId":"231","endLine":2,"endColumn":26},{"ruleId":"237","severity":1,"message":"239","line":4,"column":8,"nodeType":"230","messageId":"231","endLine":4,"endColumn":17},{"ruleId":"237","severity":1,"message":"240","line":8,"column":8,"nodeType":"230","messageId":"231","endLine":8,"endColumn":20},{"ruleId":"237","severity":1,"message":"241","line":9,"column":10,"nodeType":"230","messageId":"231","endLine":9,"endColumn":13},{"ruleId":"237","severity":1,"message":"242","line":9,"column":15,"nodeType":"230","messageId":"231","endLine":9,"endColumn":19},{"ruleId":"237","severity":1,"message":"243","line":9,"column":21,"nodeType":"230","messageId":"231","endLine":9,"endColumn":32},{"ruleId":"237","severity":1,"message":"244","line":9,"column":34,"nodeType":"230","messageId":"231","endLine":9,"endColumn":44},{"ruleId":"237","severity":1,"message":"245","line":10,"column":8,"nodeType":"230","messageId":"231","endLine":10,"endColumn":34},{"ruleId":"237","severity":1,"message":"246","line":12,"column":10,"nodeType":"230","messageId":"231","endLine":12,"endColumn":15},{"ruleId":"247","severity":1,"message":"248","line":25,"column":55,"nodeType":"249","messageId":"250","endLine":25,"endColumn":57},{"ruleId":"251","severity":1,"message":"252","line":55,"column":29,"nodeType":"253","messageId":"254","endLine":55,"endColumn":35},{"ruleId":"247","severity":1,"message":"255","line":75,"column":48,"nodeType":"249","messageId":"250","endLine":75,"endColumn":50},{"ruleId":"247","severity":1,"message":"255","line":76,"column":48,"nodeType":"249","messageId":"250","endLine":76,"endColumn":50},{"ruleId":"247","severity":1,"message":"255","line":77,"column":52,"nodeType":"249","messageId":"250","endLine":77,"endColumn":54},{"ruleId":"247","severity":1,"message":"255","line":78,"column":52,"nodeType":"249","messageId":"250","endLine":78,"endColumn":54},{"ruleId":"224","replacedBy":"225"},{"ruleId":"226","replacedBy":"227"},{"ruleId":"237","severity":1,"message":"256","line":1,"column":28,"nodeType":"230","messageId":"231","endLine":1,"endColumn":36},{"ruleId":"257","severity":1,"message":"258","line":172,"column":23,"nodeType":"259","messageId":"260","endLine":172,"endColumn":25},{"ruleId":"247","severity":1,"message":"248","line":172,"column":66,"nodeType":"249","messageId":"250","endLine":172,"endColumn":68},{"ruleId":"257","severity":1,"message":"258","line":173,"column":7,"nodeType":"259","messageId":"260","endLine":173,"endColumn":9},{"ruleId":"257","severity":1,"message":"261","line":173,"column":7,"nodeType":"259","messageId":"260","endLine":173,"endColumn":9},{"ruleId":"257","severity":1,"message":"261","line":173,"column":27,"nodeType":"259","messageId":"260","endLine":173,"endColumn":29},{"ruleId":"247","severity":1,"message":"248","line":173,"column":62,"nodeType":"249","messageId":"250","endLine":173,"endColumn":64},{"ruleId":"247","severity":1,"message":"255","line":439,"column":63,"nodeType":"249","messageId":"250","endLine":439,"endColumn":65},{"ruleId":"251","severity":1,"message":"252","line":439,"column":73,"nodeType":"253","messageId":"254","endLine":439,"endColumn":79},{"ruleId":"237","severity":1,"message":"262","line":5,"column":8,"nodeType":"230","messageId":"231","endLine":5,"endColumn":13},{"ruleId":"237","severity":1,"message":"238","line":8,"column":25,"nodeType":"230","messageId":"231","endLine":8,"endColumn":30},{"ruleId":"237","severity":1,"message":"263","line":9,"column":10,"nodeType":"230","messageId":"231","endLine":9,"endColumn":15},{"ruleId":"237","severity":1,"message":"264","line":10,"column":8,"nodeType":"230","messageId":"231","endLine":10,"endColumn":23},{"ruleId":"237","severity":1,"message":"265","line":11,"column":8,"nodeType":"230","messageId":"231","endLine":11,"endColumn":15},{"ruleId":"237","severity":1,"message":"266","line":11,"column":19,"nodeType":"230","messageId":"231","endLine":11,"endColumn":33},{"ruleId":"237","severity":1,"message":"267","line":15,"column":10,"nodeType":"230","messageId":"231","endLine":15,"endColumn":11},{"ruleId":"237","severity":1,"message":"268","line":135,"column":9,"nodeType":"230","messageId":"231","endLine":135,"endColumn":13},{"ruleId":"237","severity":1,"message":"269","line":1,"column":17,"nodeType":"230","messageId":"231","endLine":1,"endColumn":26},{"ruleId":"237","severity":1,"message":"270","line":2,"column":8,"nodeType":"230","messageId":"231","endLine":2,"endColumn":15},{"ruleId":"237","severity":1,"message":"239","line":3,"column":8,"nodeType":"230","messageId":"231","endLine":3,"endColumn":17},{"ruleId":"237","severity":1,"message":"271","line":4,"column":8,"nodeType":"230","messageId":"231","endLine":4,"endColumn":14},{"ruleId":"237","severity":1,"message":"272","line":6,"column":27,"nodeType":"230","messageId":"231","endLine":6,"endColumn":50},{"ruleId":"237","severity":1,"message":"273","line":8,"column":25,"nodeType":"230","messageId":"231","endLine":8,"endColumn":34},{"ruleId":"237","severity":1,"message":"264","line":9,"column":8,"nodeType":"230","messageId":"231","endLine":9,"endColumn":23},{"ruleId":"237","severity":1,"message":"274","line":2,"column":8,"nodeType":"230","messageId":"231","endLine":2,"endColumn":22},{"ruleId":"237","severity":1,"message":"275","line":1,"column":17,"nodeType":"230","messageId":"231","endLine":1,"endColumn":34},{"ruleId":"237","severity":1,"message":"276","line":3,"column":10,"nodeType":"230","messageId":"231","endLine":3,"endColumn":17},{"ruleId":"237","severity":1,"message":"277","line":16,"column":19,"nodeType":"230","messageId":"231","endLine":16,"endColumn":30},{"ruleId":"237","severity":1,"message":"238","line":16,"column":32,"nodeType":"230","messageId":"231","endLine":16,"endColumn":37},{"ruleId":"237","severity":1,"message":"278","line":16,"column":39,"nodeType":"230","messageId":"231","endLine":16,"endColumn":52},{"ruleId":"237","severity":1,"message":"279","line":27,"column":6,"nodeType":"230","messageId":"231","endLine":27,"endColumn":21},{"ruleId":"237","severity":1,"message":"280","line":34,"column":5,"nodeType":"230","messageId":"231","endLine":34,"endColumn":18},{"ruleId":"281","severity":1,"message":"282","line":285,"column":8,"nodeType":"283","endLine":285,"endColumn":10,"suggestions":"284"},{"ruleId":"237","severity":1,"message":"285","line":5,"column":10,"nodeType":"230","messageId":"231","endLine":5,"endColumn":22},{"ruleId":"247","severity":1,"message":"255","line":32,"column":36,"nodeType":"249","messageId":"250","endLine":32,"endColumn":38},{"ruleId":"237","severity":1,"message":"286","line":2,"column":10,"nodeType":"230","messageId":"231","endLine":2,"endColumn":17},{"ruleId":"237","severity":1,"message":"273","line":2,"column":32,"nodeType":"230","messageId":"231","endLine":2,"endColumn":41},{"ruleId":"237","severity":1,"message":"287","line":4,"column":8,"nodeType":"230","messageId":"231","endLine":4,"endColumn":17},{"ruleId":"237","severity":1,"message":"240","line":5,"column":8,"nodeType":"230","messageId":"231","endLine":5,"endColumn":20},{"ruleId":"237","severity":1,"message":"288","line":1,"column":10,"nodeType":"230","messageId":"231","endLine":1,"endColumn":25},{"ruleId":"237","severity":1,"message":"273","line":3,"column":10,"nodeType":"230","messageId":"231","endLine":3,"endColumn":19},{"ruleId":"237","severity":1,"message":"287","line":5,"column":8,"nodeType":"230","messageId":"231","endLine":5,"endColumn":17},{"ruleId":"224","replacedBy":"289"},{"ruleId":"226","replacedBy":"290"},{"ruleId":"237","severity":1,"message":"291","line":1,"column":17,"nodeType":"230","messageId":"231","endLine":1,"endColumn":26},{"ruleId":"247","severity":1,"message":"255","line":65,"column":68,"nodeType":"249","messageId":"250","endLine":65,"endColumn":70},{"ruleId":"247","severity":1,"message":"255","line":74,"column":68,"nodeType":"249","messageId":"250","endLine":74,"endColumn":70},{"ruleId":"237","severity":1,"message":"292","line":5,"column":13,"nodeType":"230","messageId":"231","endLine":5,"endColumn":17},{"ruleId":"237","severity":1,"message":"293","line":6,"column":10,"nodeType":"230","messageId":"231","endLine":6,"endColumn":21},{"ruleId":"247","severity":1,"message":"248","line":138,"column":21,"nodeType":"249","messageId":"250","endLine":138,"endColumn":23},{"ruleId":"247","severity":1,"message":"248","line":139,"column":40,"nodeType":"249","messageId":"250","endLine":139,"endColumn":42},{"ruleId":"237","severity":1,"message":"294","line":146,"column":13,"nodeType":"230","messageId":"231","endLine":146,"endColumn":27},{"ruleId":"237","severity":1,"message":"295","line":146,"column":29,"nodeType":"230","messageId":"231","endLine":146,"endColumn":35},{"ruleId":"237","severity":1,"message":"296","line":146,"column":37,"nodeType":"230","messageId":"231","endLine":146,"endColumn":48},{"ruleId":"237","severity":1,"message":"294","line":159,"column":13,"nodeType":"230","messageId":"231","endLine":159,"endColumn":27},{"ruleId":"237","severity":1,"message":"278","line":4,"column":10,"nodeType":"230","messageId":"231","endLine":4,"endColumn":23},{"ruleId":"237","severity":1,"message":"297","line":5,"column":10,"nodeType":"230","messageId":"231","endLine":5,"endColumn":18},{"ruleId":"237","severity":1,"message":"269","line":1,"column":17,"nodeType":"230","messageId":"231","endLine":1,"endColumn":26},{"ruleId":"237","severity":1,"message":"256","line":1,"column":28,"nodeType":"230","messageId":"231","endLine":1,"endColumn":36},{"ruleId":"237","severity":1,"message":"298","line":2,"column":10,"nodeType":"230","messageId":"231","endLine":2,"endColumn":22},{"ruleId":"237","severity":1,"message":"299","line":2,"column":39,"nodeType":"230","messageId":"231","endLine":2,"endColumn":56},{"ruleId":"237","severity":1,"message":"300","line":6,"column":8,"nodeType":"230","messageId":"231","endLine":6,"endColumn":15},{"ruleId":"237","severity":1,"message":"273","line":4,"column":10,"nodeType":"230","messageId":"231","endLine":4,"endColumn":19},{"ruleId":"237","severity":1,"message":"301","line":3,"column":8,"nodeType":"230","messageId":"231","endLine":3,"endColumn":14},{"ruleId":"237","severity":1,"message":"302","line":11,"column":8,"nodeType":"230","messageId":"231","endLine":11,"endColumn":18},{"ruleId":"237","severity":1,"message":"303","line":13,"column":8,"nodeType":"230","messageId":"231","endLine":13,"endColumn":18},{"ruleId":"237","severity":1,"message":"304","line":16,"column":8,"nodeType":"230","messageId":"231","endLine":16,"endColumn":12},{"ruleId":"237","severity":1,"message":"238","line":16,"column":16,"nodeType":"230","messageId":"231","endLine":16,"endColumn":21},{"ruleId":"237","severity":1,"message":"305","line":20,"column":7,"nodeType":"230","messageId":"231","endLine":20,"endColumn":13},{"ruleId":"237","severity":1,"message":"306","line":46,"column":11,"nodeType":"230","messageId":"231","endLine":46,"endColumn":18},{"ruleId":"251","severity":1,"message":"252","line":61,"column":68,"nodeType":"253","messageId":"254","endLine":61,"endColumn":74},{"ruleId":"237","severity":1,"message":"307","line":1,"column":10,"nodeType":"230","messageId":"231","endLine":1,"endColumn":26},{"ruleId":"237","severity":1,"message":"244","line":1,"column":28,"nodeType":"230","messageId":"231","endLine":1,"endColumn":38},"no-native-reassign",["308"],"no-negated-in-lhs",["309"],"no-unused-vars","'p' is assigned a value but never used.","Identifier","unusedVar",["308"],["309"],["308"],["309"],"'onClick' is assigned a value but never used.","@typescript-eslint/no-unused-vars","'Label' is defined but never used.","'Separator' is defined but never used.","'NeoMorphCard' is defined but never used.","'Box' is defined but never used.","'Card' is defined but never used.","'CardContent' is defined but never used.","'makeStyles' is defined but never used.","'ClusterChangeCommentDialog' is defined but never used.","'index' is defined but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ReturnStatement","expectedReturnValue","Expected '!==' and instead saw '!='.","'useState' is defined but never used.","no-mixed-operators","Unexpected mix of '&&' and '||'.","LogicalExpression","unexpectedMixedOperator","Unexpected mix of '||' and '&&'.","'About' is defined but never used.","'least' is defined but never used.","'SlidersParamter' is defined but never used.","'DragBar' is defined but never used.","'DRAGBAR_GUTTER' is defined but never used.","'p' is defined but never used.","'grem' is assigned a value but never used.","'Component' is defined but never used.","'Comment' is defined but never used.","'Select' is defined but never used.","'PropsForClusterOverview' is defined but never used.","'DataPoint' is defined but never used.","'ClusterSnippet' is defined but never used.","'MouseEventHandler' is defined but never used.","'lighten' is defined but never used.","'DataChanged' is defined but never used.","'PropsFromData' is defined but never used.","'ClusterInfoDict' is defined but never used.","'labelsAndData' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'rowsSorted' and 'setClustersToShow'. Either include them or remove the dependency array. If 'setClustersToShow' changes too often, find the parent component that defines it and wrap that definition in useCallback.","ArrayExpression",["310"],"'createStyles' is defined but never used.","'Cluster' is defined but never used.","'TextField' is defined but never used.","'PropsForSidebar' is defined but never used.",["308"],["309"],"'useEffect' is defined but never used.","'join' is defined but never used.","'LensTwoTone' is defined but never used.","'selected_datum' is assigned a value but never used.","'labels' is assigned a value but never used.","'labelChoice' is assigned a value but never used.","'truncate' is defined but never used.","'NumNeighbors' is defined but never used.","'num_neighbors_arr' is defined but never used.","'Toolbar' is defined but never used.","'Button' is defined but never used.","'PersonIcon' is defined but never used.","'Typography' is defined but never used.","'Data' is defined but never used.","'emails' is assigned a value but never used.","'classes' is assigned a value but never used.","'CircularProgress' is defined but never used.","no-global-assign","no-unsafe-negation",{"desc":"311","fix":"312"},"Update the dependencies array to be: [rowsSorted, setClustersToShow]",{"range":"313","text":"314"},[9205,9207],"[rowsSorted, setClustersToShow]"]